<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>é¦¬ä»¥å¤–ã®å‹•ç‰©ã‚’ã¤ã¾ã¿å‡ºã›ï¼</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: #f5e6d3;
        min-height: 100vh;
        overflow: hidden;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #game-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      #video-container {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 240px;
        height: 180px;
        border: 3px solid white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        background: #000;
        z-index: 1000;
      }

      #input_video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      #cursor {
        position: fixed;
        width: 80px;
        height: 80px;
        border: 4px solid #ff6b6b;
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        transform: translate(-50%, -50%);
        transition: all 0.1s ease;
        background: rgba(255, 107, 107, 0.2);
      }

      #cursor.pinching {
        width: 40px;
        height: 40px;
        border-color: #4ecdc4;
        background: rgba(78, 205, 196, 0.4);
        box-shadow: 0 0 20px rgba(78, 205, 196, 0.6);
      }

      #cursor.grabbing {
        width: 100px;
        height: 100px;
        border-color: #ffe66d;
        background: rgba(255, 230, 109, 0.4);
        animation: pulse 0.3s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.1); }
      }

      #info {
        position: fixed;
        top: 20px;
        left: 20px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 248, 240, 0.95));
        padding: 20px 24px;
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(139, 90, 43, 0.15);
        max-width: 280px;
        z-index: 1000;
        border: 2px solid rgba(139, 90, 43, 0.1);
      }

      #info h1 {
        font-size: 17px;
        color: #8B5A2B;
        margin-bottom: 12px;
        font-weight: bold;
      }

      #info p {
        font-size: 13px;
        color: #6B4423;
        margin: 6px 0;
        opacity: 0.9;
      }

      #score {
        font-size: 26px;
        font-weight: bold;
        color: #2E8B57;
        margin-top: 14px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.1);
      }

      #remaining {
        font-size: 15px;
        color: #CD853F;
        margin-top: 6px;
        font-weight: 500;
      }

      #status {
        margin-top: 14px;
        padding: 10px 14px;
        background: linear-gradient(135deg, #f5f0e8, #ebe5db);
        border-radius: 12px;
        font-weight: bold;
        color: #8B7355;
        font-size: 12px;
        text-align: center;
      }

      #status.active {
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        color: #2E7D32;
      }

      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        text-align: center;
        z-index: 10000;
      }

      #loading.hidden {
        display: none;
      }

      .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #c9684a;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      #clear-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 20000;
      }

      #clear-modal.show {
        display: flex;
      }

      #clear-content {
        background: white;
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        animation: bounceIn 0.5s ease;
      }

      @keyframes bounceIn {
        0% { transform: scale(0); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }

      #clear-content h2 {
        font-size: 36px;
        color: #4ecdc4;
        margin-bottom: 20px;
      }

      #clear-content p {
        font-size: 18px;
        color: #666;
        margin-bottom: 20px;
      }

      #restart-btn {
        padding: 15px 40px;
        font-size: 18px;
        background: #ff6b6b;
        color: white;
        border: none;
        border-radius: 30px;
        cursor: pointer;
        transition: transform 0.2s;
      }

      #restart-btn:hover {
        transform: scale(1.05);
      }

      /* æ•ç²ã‚¨ãƒªã‚¢ */
      #capture-zone {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 120px;
        background: linear-gradient(to top, rgba(78, 205, 196, 0.3), transparent);
        z-index: 500;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 10px;
      }

      #capture-zone p {
        color: #4ecdc4;
        font-weight: bold;
        font-size: 14px;
        text-shadow: 0 0 10px white;
      }

      #captured-animals {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        z-index: 600;
      }

      .captured-icon {
        width: 50px;
        height: 50px;
        background: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        animation: popIn 0.3s ease;
      }

      @keyframes popIn {
        0% { transform: scale(0) rotate(-180deg); }
        100% { transform: scale(1) rotate(0deg); }
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <div class="spinner"></div>
      <p>ã‚«ãƒ¡ãƒ©ã¨MediaPipeã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
    </div>

    <div id="container">
      <canvas id="game-canvas"></canvas>

      <div id="info">
        <h1>é¦¬ä»¥å¤–ã®å‹•ç‰©ã‚’ã¤ã¾ã¿å‡ºã›ï¼</h1>
        <p>ğŸ‘† äººå·®ã—æŒ‡ã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã™</p>
        <p>ğŸ‘Œ å‹•ç‰©ã‚’ãƒ”ãƒ³ãƒã§ã¤ã¾ã‚€</p>
        <p>ğŸ§º ç± ã«ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ•ç²ï¼</p>
        <div id="score">ã‚¹ã‚³ã‚¢: 0</div>
        <div id="remaining">æ®‹ã‚Š: 0åŒ¹</div>
        <div id="status">å¾…æ©Ÿä¸­...</div>
      </div>

      <div id="video-container">
        <video id="input_video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
      </div>

      <div id="cursor"></div>

      <!-- ç± ãŒã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã«è¡¨ç¤ºã•ã‚Œã‚‹ãŸã‚éè¡¨ç¤º -->
      <!-- <div id="capture-zone">
        <p>ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦æ•ç²ï¼</p>
      </div> -->

      <div id="captured-animals"></div>
    </div>

    <div id="clear-modal">
      <div id="clear-content">
        <h2>ğŸ‰ ã‚¯ãƒªã‚¢ï¼</h2>
        <p>å…¨ã¦ã®å‹•ç‰©ã‚’è¦‹ã¤ã‘ã¾ã—ãŸï¼</p>
        <button id="restart-btn">ã‚‚ã†ä¸€åº¦éŠã¶</button>
      </div>
    </div>

    <script type="module">
      import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

      const videoElement = document.getElementById("input_video");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const cursor = document.getElementById("cursor");
      const status = document.getElementById("status");
      const loading = document.getElementById("loading");
      const gameCanvas = document.getElementById("game-canvas");
      const gameCtx = gameCanvas.getContext("2d");
      const scoreElement = document.getElementById("score");
      const remainingElement = document.getElementById("remaining");
      const clearModal = document.getElementById("clear-modal");
      const restartBtn = document.getElementById("restart-btn");
      const capturedAnimalsDiv = document.getElementById("captured-animals");
      const captureZone = document.getElementById("capture-zone");

      let smoothX = window.innerWidth / 2;
      let smoothY = window.innerHeight / 2;
      let isPinching = false;
      let handLandmarker = null;
      let lastVideoTime = -1;

      // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ç”¨
      const smoothing = 0.3; // å°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼ˆ0.1ã€œ0.5ï¼‰

      // ãƒ”ãƒ³ãƒã®ãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ï¼ˆã¤ã¾ã‚“ã ã‚‰é›¢ã—ã«ããã™ã‚‹ï¼‰
      const pinchStartThreshold = 0.09;  // ã¤ã¾ã‚€é–‹å§‹
      const pinchEndThreshold = 0.13;    // é›¢ã™åˆ¤å®šï¼ˆã‚ˆã‚Šç·©ãï¼‰

      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
      let score = 0;
      let grabbedAnimal = null;
      let grabOffset = { x: 0, y: 0 };
      let horses = [];
      let hiddenAnimals = [];
      let capturedAnimals = [];

      // ç± ã®ä½ç½®ã¨ã‚µã‚¤ã‚º
      const kago = {
        x: 0,
        y: 0,
        width: 200,
        height: 150
      };

      // ç ‚ç…™ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
      let dustParticles = [];

      // è‰ã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«ä½ç½®ï¼ˆå›ºå®šï¼‰
      let grassDetails = [];

      // ã‚­ãƒ©ã‚­ãƒ©ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
      let sparkleParticles = [];

      // ã¤ã‹ã‚€æ™‚ã®æ³¢ç´‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      let ripples = [];

      // åŠ¹æœéŸ³ã‚’ç”Ÿæˆ
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      function playSound(type) {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        if (type === 'grab') {
          // ã¤ã‹ã‚€éŸ³ï¼ˆã½ã‚ã‚“ï¼‰æŸ”ã‚‰ã‹ã
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(330, audioCtx.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.08);
          oscillator.frequency.exponentialRampToValueAtTime(350, audioCtx.currentTime + 0.15);
          gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.2);
        } else if (type === 'capture') {
          // æ•ç²éŸ³ï¼ˆã‚­ãƒ©ãƒ¼ãƒ³ï¼‰
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
          oscillator.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
          oscillator.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
          gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.4);
        }
      }

      // æ³¢ç´‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç™ºç”Ÿ
      function createRipple(x, y, color = '#FFD700') {
        ripples.push({
          x: x,
          y: y,
          radius: 10,
          maxRadius: 60,
          alpha: 0.8,
          color: color
        });
      }

      // æ³¢ç´‹ã‚’æ›´æ–°ãƒ»æç”»
      function updateAndDrawRipples(ctx) {
        for (let i = ripples.length - 1; i >= 0; i--) {
          const r = ripples[i];
          r.radius += 3;
          r.alpha -= 0.04;

          if (r.alpha > 0) {
            ctx.save();
            ctx.strokeStyle = r.color;
            ctx.lineWidth = 3;
            ctx.globalAlpha = r.alpha;
            ctx.beginPath();
            ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          } else {
            ripples.splice(i, 1);
          }
        }
      }

      // ã‚­ãƒ©ã‚­ãƒ©ã‚’ç™ºç”Ÿ
      function createSparkles(x, y) {
        for (let i = 0; i < 12; i++) {
          const angle = (Math.PI * 2 * i) / 12;
          sparkleParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * (3 + Math.random() * 2),
            vy: Math.sin(angle) * (3 + Math.random() * 2),
            size: 4 + Math.random() * 4,
            color: ['#FFD700', '#FFA500', '#FF69B4', '#00CED1'][Math.floor(Math.random() * 4)],
            life: 1.0
          });
        }
      }

      // ã‚­ãƒ©ã‚­ãƒ©ã‚’æ›´æ–°ãƒ»æç”»
      function updateAndDrawSparkles(ctx) {
        for (let i = sparkleParticles.length - 1; i >= 0; i--) {
          const p = sparkleParticles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1; // é‡åŠ›
          p.life -= 0.03;
          p.vx *= 0.98;

          if (p.life > 0) {
            ctx.save();
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            // æ˜Ÿå½¢ã‚’æç”»
            ctx.beginPath();
            for (let j = 0; j < 5; j++) {
              const angle = (j * Math.PI * 2) / 5 - Math.PI / 2;
              const r = j % 2 === 0 ? p.size : p.size * 0.4;
              if (j === 0) ctx.moveTo(p.x + r * Math.cos(angle), p.y + r * Math.sin(angle));
              else ctx.lineTo(p.x + r * Math.cos(angle), p.y + r * Math.sin(angle));
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          } else {
            sparkleParticles.splice(i, 1);
          }
        }
      }

      // ç”»åƒã‚’èª­ã¿è¾¼ã¿
      const images = {};
      let imagesLoaded = 0;
      const imageFiles = ['uma', 'ushi', 'saru', 'hebi', 'kago'];

      imageFiles.forEach(name => {
        images[name] = new Image();
        images[name].onload = () => {
          imagesLoaded++;
          if (imagesLoaded === imageFiles.length) {
            console.log('å…¨ç”»åƒèª­ã¿è¾¼ã¿å®Œäº†');
            resizeCanvas();
          }
        };
        images[name].src = `horse_game-images/${name}.png`;
      });

      // éš ã‚Œã¦ã„ã‚‹å‹•ç‰©ã®ç¨®é¡ï¼ˆé¦¬ä»¥å¤–ï¼‰
      const animalTypes = [
        { type: "ushi", name: "ç‰›", emoji: "ğŸ„" },
        { type: "saru", name: "çŒ¿", emoji: "ğŸµ" },
        { type: "hebi", name: "è›‡", emoji: "ğŸ" },
      ];

      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
      function resizeCanvas() {
        gameCanvas.width = window.innerWidth;
        gameCanvas.height = window.innerHeight;
        // ç”»åƒãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚Œã°åˆæœŸåŒ–
        if (imagesLoaded === imageFiles.length) {
          initGame();
        }
      }

      // é¦¬ã‚’æç”»ï¼ˆç”»åƒã‚’ä½¿ç”¨ï¼‰
      function drawHorse(ctx, x, y, size, isFlipped = false) {
        if (!images.uma) return;
        ctx.save();
        ctx.translate(x, y);
        if (isFlipped) ctx.scale(-1, 1);

        const img = images.uma;
        const scale = size / 80;
        const w = img.width * scale;
        const h = img.height * scale;
        ctx.drawImage(img, -w / 2, -h / 2, w, h);
        ctx.restore();
      }

      // éš ã‚Œã¦ã„ã‚‹å‹•ç‰©ã‚’æç”»ï¼ˆç”»åƒã‚’ä½¿ç”¨ï¼‰
      function drawAnimal(ctx, animal) {
        const img = images[animal.type];
        if (!img) return;

        ctx.save();
        ctx.translate(animal.x, animal.y);

        const scale = animal.size / 80;
        const w = img.width * scale;
        const h = img.height * scale;
        ctx.drawImage(img, -w / 2, -h / 2, w, h);

        ctx.restore();
      }

      // ç± ã‚’æç”»
      function drawKago(ctx) {
        if (!images.kago) return;
        const img = images.kago;
        const scale = kago.width / img.width;
        const h = img.height * scale;
        kago.height = h;
        ctx.drawImage(img, kago.x - kago.width / 2, kago.y - h / 2, kago.width, h);
      }

      // ç± ã®ä¸­ã«ã„ã‚‹ã‹åˆ¤å®š
      function isInKago(x, y) {
        const dx = Math.abs(x - kago.x);
        const dy = Math.abs(y - kago.y);
        return dx < kago.width / 2 - 20 && dy < kago.height / 2 - 10;
      }

      // ç± ã®å¸å¼•ç¯„å›²ã«ã„ã‚‹ã‹åˆ¤å®š
      function isNearKago(x, y) {
        const dx = x - kago.x;
        const dy = y - kago.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        return dist < kago.width * 0.8; // ç± ã®è¿‘ãã«æ¥ãŸã‚‰å¸å¼•é–‹å§‹
      }

      // å¸å¼•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®å‹•ç‰©
      let beingSucked = null;

      // ç± ã«å¸ã„è¾¼ã‚€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      function suckIntoKago(animal) {
        beingSucked = animal;
        animal.isGrabbed = false;
        grabbedAnimal = null;
        cursor.classList.remove("grabbing");

        const startX = animal.x;
        const startY = animal.y;
        const startSize = animal.size;
        let progress = 0;

        function animate() {
          progress += 0.08; // å¸ã„è¾¼ã¿é€Ÿåº¦

          if (progress >= 1) {
            // å¸ã„è¾¼ã¿å®Œäº†
            animal.x = kago.x;
            animal.y = kago.y;
            animal.size = 0;
            beingSucked = null;
            captureAnimal(animal);
            return;
          }

          // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆåŠ é€Ÿã—ãªãŒã‚‰å¸ã„è¾¼ã¾ã‚Œã‚‹ï¼‰
          const ease = progress * progress;

          animal.x = startX + (kago.x - startX) * ease;
          animal.y = startY + (kago.y - startY) * ease;
          animal.size = startSize * (1 - ease * 0.8); // å°ã•ããªã‚‹

          requestAnimationFrame(animate);
        }

        animate();
      }

      // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
      function initGame() {
        horses = [];
        hiddenAnimals = [];
        capturedAnimals = [];
        score = 0;
        grabbedAnimal = null;
        beingSucked = null;
        dustParticles = [];
        sparkleParticles = [];
        ripples = [];
        capturedAnimalsDiv.innerHTML = "";
        clearModal.classList.remove("show");

        const width = gameCanvas.width;
        const height = gameCanvas.height;

        // ç± ã®ä½ç½®ã‚’è¨­å®šï¼ˆç”»é¢å³ä¸‹ï¼‰
        kago.x = width - 150;
        kago.y = height - 120;

        // è‰ã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«ã‚’ç”Ÿæˆ
        grassDetails = [];
        for (let i = 0; i < 80; i++) {
          grassDetails.push({
            x: Math.random() * width,
            y: height * 0.5 + Math.random() * (height * 0.4)
          });
        }
        const horseSize = 80;
        const spacingX = 120; // æ¨ªã®é–“éš”
        const spacingY = 100; // ç¸¦ã®é–“éš”
        const cols = Math.ceil(width / spacingX);
        const rows = Math.ceil((height - 120) / spacingY); // ä¸‹ã®æ•ç²ã‚¨ãƒªã‚¢ã‚’é™¤ã

        // é¦¬ã‚’é…ç½®ï¼ˆå³ã‹ã‚‰å·¦ã¸èµ°ã‚‹ï¼‰
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const x = col * spacingX + (row % 2) * (spacingX / 2) + 60 + Math.random() * 30 - 15;
            const y = row * spacingY + 80 + Math.random() * 20 - 10;
            const speed = 2 + Math.random() * 2; // ç§»å‹•é€Ÿåº¦ï¼ˆé€Ÿã‚ï¼‰
            horses.push({
              x: x,
              y: y,
              vx: -speed, // å·¦æ–¹å‘ã¸
              vy: 0,
              size: horseSize + Math.random() * 20 - 10,
              flipped: false // å…¨ã¦å·¦å‘ã
            });
          }
        }

        // éš ã‚Œã¦ã„ã‚‹å‹•ç‰©ã‚’é…ç½®ï¼ˆé¦¬ã®ä½ç½®ã‚’ä¸€éƒ¨ç½®ãæ›ãˆï¼‰
        const numAnimals = Math.min(5, Math.max(3, Math.floor(horses.length / 8)));
        const usedIndices = new Set();

        for (let i = 0; i < numAnimals; i++) {
          let idx;
          do {
            idx = Math.floor(Math.random() * horses.length);
          } while (usedIndices.has(idx));
          usedIndices.add(idx);

          const horse = horses[idx];
          const animalType = animalTypes[i % animalTypes.length];

          hiddenAnimals.push({
            id: i,
            x: horse.x,
            y: horse.y,
            vx: (Math.random() - 0.5) * 1.5, // ã‚†ã£ãã‚Šãƒ©ãƒ³ãƒ€ãƒ ã«å‹•ã
            vy: (Math.random() - 0.5) * 1.5,
            baseX: horse.x, // åˆæœŸä½ç½®ã‚’è¨˜æ†¶
            baseY: horse.y,
            size: horse.size,
            type: animalType.type,
            name: animalType.name,
            emoji: animalType.emoji,
            isGrabbed: false,
            isCaptured: false
          });

          // é¦¬ã®ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
          horses.splice(idx, 1);
        }

        updateUI();
        render();
      }

      // UIæ›´æ–°
      function updateUI() {
        const remaining = hiddenAnimals.filter(a => !a.isCaptured).length;
        scoreElement.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
        remainingElement.textContent = `æ®‹ã‚Š: ${remaining}åŒ¹`;
      }

      // å‹•ç‰©ã®ç§»å‹•æ›´æ–°
      function updatePositions() {
        const margin = 50;
        const maxY = gameCanvas.height - 150; // æ•ç²ã‚¨ãƒªã‚¢ã®ä¸Š

        // é¦¬ã‚’å‹•ã‹ã™ï¼ˆå³ã‹ã‚‰å·¦ã¸ãƒ«ãƒ¼ãƒ—ï¼‰
        horses.forEach(horse => {
          horse.x += horse.vx;

          // å·¦ç«¯ã‚’è¶…ãˆãŸã‚‰å³ç«¯ã‹ã‚‰å‡ºã¦ãã‚‹
          if (horse.x < -50) {
            horse.x = gameCanvas.width + 50;
          }
        });

        // éš ã‚Œå‹•ç‰©ã‚‚ã‚†ã‚‰ã‚†ã‚‰å‹•ã
        hiddenAnimals.forEach(animal => {
          if (animal.isCaptured || animal.isGrabbed || animal === beingSucked) return;

          animal.x += animal.vx;
          animal.y += animal.vy;

          // åˆæœŸä½ç½®ã‹ã‚‰é›¢ã‚Œã™ããŸã‚‰æ–¹å‘è»¢æ›
          const wanderRange = 80; // å‹•ãå›ã‚‹ç¯„å›²
          const dx = animal.x - animal.baseX;
          const dy = animal.y - animal.baseY;

          if (Math.abs(dx) > wanderRange) {
            animal.vx = -animal.vx;
            animal.x = animal.baseX + (dx > 0 ? wanderRange : -wanderRange);
          }
          if (Math.abs(dy) > wanderRange) {
            animal.vy = -animal.vy;
            animal.y = animal.baseY + (dy > 0 ? wanderRange : -wanderRange);
          }

          // æ™‚ã€…æ–¹å‘ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰ãˆã‚‹
          if (Math.random() < 0.01) {
            animal.vx = (Math.random() - 0.5) * 1.5;
            animal.vy = (Math.random() - 0.5) * 1.5;
          }
        });
      }

      // ç‰§å ´èƒŒæ™¯ã‚’æç”»
      function drawBackground(ctx) {
        const w = gameCanvas.width;
        const h = gameCanvas.height;

        // ç©ºï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        const skyGradient = ctx.createLinearGradient(0, 0, 0, h * 0.4);
        skyGradient.addColorStop(0, '#87CEEB');  // æ°´è‰²
        skyGradient.addColorStop(1, '#E0F4FF');  // è–„ã„é’
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, w, h * 0.4);

        // é ãã®å±±
        ctx.fillStyle = '#8FBC8F';
        ctx.beginPath();
        ctx.moveTo(0, h * 0.4);
        for (let x = 0; x <= w; x += 100) {
          const mountainHeight = Math.sin(x * 0.01) * 30 + Math.sin(x * 0.02) * 20;
          ctx.lineTo(x, h * 0.35 - mountainHeight);
        }
        ctx.lineTo(w, h * 0.4);
        ctx.closePath();
        ctx.fill();

        // è‰åŸï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        const grassGradient = ctx.createLinearGradient(0, h * 0.35, 0, h);
        grassGradient.addColorStop(0, '#90EE90');  // æ˜ã‚‹ã„ç·‘
        grassGradient.addColorStop(0.3, '#7CCD7C');
        grassGradient.addColorStop(1, '#C4A76C');  // åœŸè‰²
        ctx.fillStyle = grassGradient;
        ctx.fillRect(0, h * 0.35, w, h * 0.65);

        // æŸµï¼ˆå¥¥ï¼‰
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 4;
        const fenceY = h * 0.38;
        // æ¨ªæ£’
        ctx.beginPath();
        ctx.moveTo(0, fenceY);
        ctx.lineTo(w, fenceY);
        ctx.moveTo(0, fenceY + 15);
        ctx.lineTo(w, fenceY + 15);
        ctx.stroke();
        // ç¸¦æ£’
        for (let x = 30; x < w; x += 80) {
          ctx.beginPath();
          ctx.moveTo(x, fenceY - 10);
          ctx.lineTo(x, fenceY + 30);
          ctx.stroke();
        }

        // è‰ã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«ï¼ˆå›ºå®šä½ç½®ï¼‰
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 2;
        grassDetails.forEach(grass => {
          ctx.beginPath();
          ctx.moveTo(grass.x, grass.y);
          ctx.quadraticCurveTo(grass.x + 3, grass.y - 15, grass.x + 6, grass.y);
          ctx.stroke();
        });
      }

      // ç ‚ç…™ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ
      function createDustParticle(x, y) {
        dustParticles.push({
          x: x + Math.random() * 15 - 7,
          y: y + Math.random() * 5,
          vx: Math.random() * 1.5 - 0.75,
          vy: -Math.random() * 1 - 0.3,
          size: Math.random() * 8 + 5,  // å°ã•ã‚
          alpha: 0.4 + Math.random() * 0.2,
          life: 0.6  // æ—©ãæ¶ˆãˆã‚‹
        });
      }

      // ç ‚ç…™ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ›´æ–°ãƒ»æç”»
      function updateAndDrawDust(ctx) {
        for (let i = dustParticles.length - 1; i >= 0; i--) {
          const p = dustParticles[i];

          // æ›´æ–°
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.02; // é‡åŠ›
          p.life -= 0.02;
          p.size *= 1.01; // å°‘ã—å¤§ãããªã‚‹
          p.alpha = p.life * 0.5;

          // æç”»
          if (p.life > 0) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(210, 180, 140, ${p.alpha})`;
            ctx.fill();
          } else {
            dustParticles.splice(i, 1);
          }
        }
      }

      // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      function render() {
        // ä½ç½®ã‚’æ›´æ–°
        updatePositions();

        gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        // ç‰§å ´èƒŒæ™¯
        drawBackground(gameCtx);

        // é¦¬ã¨éš ã‚Œå‹•ç‰©ã‚’ã¾ã¨ã‚ã¦Yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆã—ã¦æç”»ï¼ˆå¥¥ã‹ã‚‰æ‰‹å‰ã¸ï¼‰
        const allEntities = [
          ...horses.map(h => ({ ...h, isHorse: true })),
          ...hiddenAnimals.filter(a => !a.isCaptured).map(a => ({ ...a, isHorse: false }))
        ];

        // Yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆï¼ˆå°ã•ã„ï¼å¥¥ã®ã‚‚ã®ã‚’å…ˆã«æç”»ï¼‰
        allEntities.sort((a, b) => a.y - b.y);

        allEntities.forEach(entity => {
          if (entity.isHorse) {
            drawHorse(gameCtx, entity.x, entity.y, entity.size, entity.flipped);
            // é¦¬ã®å¾Œã‚ã«ç ‚ç…™ã‚’ç™ºç”Ÿï¼ˆæ§ãˆã‚ã«ï¼‰
            if (Math.random() < 0.08) {
              createDustParticle(entity.x + 30, entity.y + entity.size * 0.3);
            }
          } else {
            drawAnimal(gameCtx, entity);
          }
        });

        // ç ‚ç…™ã‚’æç”»
        updateAndDrawDust(gameCtx);

        // ç± ã‚’æç”»ï¼ˆæœ€å‰é¢ï¼‰
        drawKago(gameCtx);

        // æ³¢ç´‹ã‚’æç”»
        updateAndDrawRipples(gameCtx);

        // ã‚­ãƒ©ã‚­ãƒ©ã‚’æç”»
        updateAndDrawSparkles(gameCtx);

        requestAnimationFrame(render);
      }

      // å‹•ç‰©ã¨ã®å½“ãŸã‚Šåˆ¤å®š
      function checkAnimalHit(x, y) {
        for (const animal of hiddenAnimals) {
          if (animal.isCaptured) continue;
          const dx = x - animal.x;
          const dy = y - animal.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < animal.size * 0.9) { // å½“ãŸã‚Šåˆ¤å®šã‚’åºƒã’ã¦ã¤ã¾ã¿ã‚„ã™ã
            return animal;
          }
        }
        return null;
      }

      // æ•ç²ã‚¾ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
      function isInCaptureZone(y) {
        return y > gameCanvas.height - 120;
      }

      // å‹•ç‰©ã‚’æ•ç²
      function captureAnimal(animal) {
        animal.isCaptured = true;
        capturedAnimals.push(animal);
        score += 100;

        // åŠ¹æœéŸ³ã¨ã‚­ãƒ©ã‚­ãƒ©
        playSound('capture');
        createSparkles(kago.x, kago.y);

        // æ•ç²ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¿½åŠ 
        const icon = document.createElement("div");
        icon.className = "captured-icon";
        icon.textContent = animal.emoji;
        capturedAnimalsDiv.appendChild(icon);

        updateUI();

        // å…¨éƒ¨æ•ç²ã—ãŸã‚‰ã‚¯ãƒªã‚¢
        const remaining = hiddenAnimals.filter(a => !a.isCaptured).length;
        if (remaining === 0) {
          setTimeout(() => {
            clearModal.classList.add("show");
          }, 500);
        }
      }

      // MediaPipeåˆæœŸåŒ–
      async function initializeHandLandmarker() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.7,
          minHandPresenceConfidence: 0.7,
          minTrackingConfidence: 0.7,
        });
      }

      function processHandLandmarks(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.landmarks && results.landmarks.length > 0) {
          const landmarks = results.landmarks[0];

          // æ‰‹ã®éª¨æ ¼ã‚’æç”»
          canvasCtx.strokeStyle = "#00ff00";
          canvasCtx.lineWidth = 2;

          const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17],
          ];

          connections.forEach(([start, end]) => {
            const startPoint = landmarks[start];
            const endPoint = landmarks[end];
            canvasCtx.beginPath();
            canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
            canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
            canvasCtx.stroke();
          });

          // äººå·®ã—æŒ‡ã®å…ˆç«¯
          const indexFingerTip = landmarks[8];
          const targetX = (1.0 - indexFingerTip.x) * window.innerWidth;
          const targetY = indexFingerTip.y * window.innerHeight;

          // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆæ€¥ãªå‹•ãã‚’æŠ‘åˆ¶ï¼‰
          smoothX += (targetX - smoothX) * smoothing;
          smoothY += (targetY - smoothY) * smoothing;

          cursor.style.left = `${smoothX}px`;
          cursor.style.top = `${smoothY}px`;
          cursor.style.display = "block";

          // ãƒ”ãƒ³ãƒã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ¤œå‡º
          const thumbTip = landmarks[4];
          const distance = Math.sqrt(
            Math.pow(indexFingerTip.x - thumbTip.x, 2) +
            Math.pow(indexFingerTip.y - thumbTip.y, 2) +
            Math.pow(indexFingerTip.z - thumbTip.z, 2)
          );

          const wasPinching = isPinching;
          // ãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹: ã¤ã¾ã‚“ã§ã„ã‚‹æ™‚ã¯é›¢ã—ã«ãã
          if (isPinching) {
            // å‹•ç‰©ã‚’ã¤ã¾ã‚“ã§ã„ã‚‹æ™‚ã¯ã•ã‚‰ã«é›¢ã—ã«ãã
            const threshold = grabbedAnimal ? pinchEndThreshold + 0.03 : pinchEndThreshold;
            isPinching = distance < threshold;
          } else {
            isPinching = distance < pinchStartThreshold;
          }

          if (isPinching && !wasPinching) {
            // ãƒ”ãƒ³ãƒé–‹å§‹
            cursor.classList.add("pinching");
            const animal = checkAnimalHit(smoothX, smoothY);
            if (animal && !animal.isCaptured) {
              grabbedAnimal = animal;
              grabbedAnimal.isGrabbed = true;
              grabOffset.x = smoothX - animal.x;
              grabOffset.y = smoothY - animal.y;
              cursor.classList.remove("pinching");
              cursor.classList.add("grabbing");
              playSound('grab');
              createRipple(animal.x, animal.y, '#ffe66d'); // æ³¢ç´‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            }
          } else if (!isPinching && wasPinching) {
            // ãƒ”ãƒ³ãƒçµ‚äº†
            cursor.classList.remove("pinching");
            cursor.classList.remove("grabbing");

            if (grabbedAnimal) {
              grabbedAnimal.isGrabbed = false;
              if (isInKago(grabbedAnimal.x, grabbedAnimal.y)) {
                captureAnimal(grabbedAnimal);
              }
              // é›¢ã—ãŸã‚‰ç¾åœ¨ä½ç½®ã‹ã‚‰ã¾ãŸå‹•ãå‡ºã™
              grabbedAnimal = null;
            }
          }

          // å‹•ç‰©ã‚’ãƒ‰ãƒ©ãƒƒã‚°
          if (grabbedAnimal && isPinching) {
            grabbedAnimal.x = smoothX - grabOffset.x;
            grabbedAnimal.y = smoothY - grabOffset.y;

            // ç± ã®è¿‘ãã«æ¥ãŸã‚‰å¸ã„è¾¼ã¿é–‹å§‹
            if (isNearKago(grabbedAnimal.x, grabbedAnimal.y)) {
              suckIntoKago(grabbedAnimal);
            }
          }

          status.textContent = "æ‰‹ã‚’æ¤œå‡ºä¸­ âœ“";
          status.classList.add("active");
        } else {
          status.textContent = "æ‰‹ãŒè¦‹ãˆã¾ã›ã‚“...";
          status.classList.remove("active");
        }

        canvasCtx.restore();
      }

      async function startCamera() {
        await initializeHandLandmarker();

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“";
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
          });
          videoElement.srcObject = stream;

          videoElement.addEventListener("loadeddata", () => {
            loading.classList.add("hidden");

            function onFrame() {
              if (!handLandmarker) return;

              const startTimeMs = performance.now();

              if (videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                processHandLandmarks(results);
              }

              requestAnimationFrame(onFrame);
            }
            onFrame();
          });
        } catch (error) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—: " + error.message;
        }
      }

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      window.addEventListener("resize", resizeCanvas);
      restartBtn.addEventListener("click", initGame);

      // åˆæœŸåŒ–
      resizeCanvas();
      startCamera();
    </script>
  </body>
</html>
