<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ›¸ãåˆã‚ - ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã§æ›¸é“</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Hiragino Kaku Gothic ProN", "ãƒ¡ã‚¤ãƒªã‚ª", sans-serif;
        min-height: 100vh;
        overflow: hidden;
        background: #2c1810;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      /* å’Œé¢¨èƒŒæ™¯ */
      #background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #8b4513 0%, #654321 50%, #3d2914 100%);
        z-index: -2;
      }

      /* ç•³æ¨¡æ§˜ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
      #background::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 20px,
            rgba(0, 0, 0, 0.1) 20px,
            rgba(0, 0, 0, 0.1) 21px
          ),
          repeating-linear-gradient(
            90deg,
            transparent,
            transparent 20px,
            rgba(0, 0, 0, 0.1) 20px,
            rgba(0, 0, 0, 0.1) 21px
          );
        pointer-events: none;
      }

      #top-banner {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        padding: 15px;
        background: linear-gradient(180deg, rgba(139, 69, 19, 0.9) 0%, transparent 100%);
        text-align: center;
        z-index: 100;
      }

      #top-banner h1 {
        color: #ffd700;
        font-size: 28px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-weight: bold;
      }

      #video-container {
        position: fixed;
        top: 100px;
        right: 20px;
        width: 240px;
        height: 180px;
        border: 3px solid #ffd700;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        background: #000;
        z-index: 1000;
      }

      #input_video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      /* æ›¸é“ã‚¨ãƒªã‚¢ */
      #calligraphy-area {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }

      /* åŠç´™ */
      #paper-container {
        position: relative;
        width: 400px;
        height: 600px;
      }

      #paper-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 4px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      /* æç”»ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ */
      #drawing-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        border-radius: 4px;
      }

      /* ç­†ã‚«ãƒ¼ã‚½ãƒ« */
      #pen-cursor {
        position: fixed;
        height: 120px;
        width: auto;
        pointer-events: none;
        z-index: 9999;
        transform: translate(-50%, -10%);
        transition: opacity 0.2s;
        filter: drop-shadow(2px 4px 6px rgba(0, 0, 0, 0.4));
      }

      #pen-cursor.hidden {
        opacity: 0;
      }

      #pen-cursor.active {
        filter: drop-shadow(2px 4px 6px rgba(0, 0, 0, 0.4)) brightness(1.2);
      }

      /* å¢¨æ±ã‚¨ãƒªã‚¢ */
      #charcoal-container {
        position: fixed;
        bottom: 50px;
        left: 50px;
        width: 120px;
        z-index: 100;
      }

      #charcoal-image {
        width: 100%;
        filter: drop-shadow(2px 4px 6px rgba(0, 0, 0, 0.4));
      }

      /* èª¬æ˜ãƒ‘ãƒãƒ« */
      #info {
        position: fixed;
        top: 100px;
        left: 20px;
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        max-width: 260px;
        z-index: 1000;
        border: 2px solid #8b4513;
      }

      #info h2 {
        margin-bottom: 10px;
        color: #8b4513;
        font-size: 18px;
      }

      #info p {
        margin: 8px 0;
        color: #333;
        font-size: 13px;
        line-height: 1.5;
      }

      #status {
        margin-top: 12px;
        padding: 8px 12px;
        background: #f0f0f0;
        border-radius: 6px;
        font-weight: bold;
        color: #666;
        text-align: center;
        font-size: 14px;
      }

      #status.active {
        background: #d4edda;
        color: #155724;
      }

      #status.writing {
        background: #fff3cd;
        color: #856404;
      }

      /* ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */
      #button-area {
        position: fixed;
        bottom: 30px;
        right: 30px;
        display: flex;
        gap: 15px;
        z-index: 1000;
      }

      .control-btn {
        padding: 15px 30px;
        font-size: 16px;
        font-weight: bold;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      #clear-btn {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
      }

      #clear-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
      }

      #save-btn {
        background: linear-gradient(135deg, #27ae60, #229954);
        color: white;
      }

      #save-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
      }

      /* å¤ªã•èª¿æ•´ */
      #brush-size-container {
        position: fixed;
        bottom: 100px;
        right: 30px;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        border-radius: 10px;
        z-index: 1000;
        border: 2px solid #8b4513;
      }

      #brush-size-container label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: #333;
      }

      #brush-size {
        width: 150px;
        cursor: pointer;
      }

      /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        text-align: center;
        z-index: 10000;
      }

      #loading.hidden {
        display: none;
      }

      .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #8b4513;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* ã¤ã¾ã¿çŠ¶æ…‹ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
      #pinch-indicator {
        position: fixed;
        bottom: 200px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 20px;
        font-size: 18px;
        z-index: 1000;
        transition: all 0.2s;
        opacity: 0;
      }

      #pinch-indicator.show {
        opacity: 1;
      }

      #pinch-indicator.pinching {
        background: rgba(39, 174, 96, 0.9);
      }

      /* å¢¨ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
      #ink-indicator {
        position: fixed;
        bottom: 180px;
        left: 50px;
        width: 120px;
        height: 20px;
        background: #ddd;
        border-radius: 10px;
        overflow: hidden;
        z-index: 1000;
      }

      #ink-level {
        height: 100%;
        background: linear-gradient(90deg, #1a1a1a, #333);
        width: 100%;
        transition: width 0.3s;
      }

      #ink-label {
        position: fixed;
        bottom: 205px;
        left: 50px;
        color: white;
        font-size: 14px;
        z-index: 1000;
        text-shadow: 1px 1px 2px black;
      }

      /* ã‚¯ãƒªã‚¢ã‚¨ãƒªã‚¢ï¼ˆå³ä¸‹ï¼‰ */
      #clear-area {
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 150px;
        height: 150px;
        background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(192, 57, 43, 0.3));
        border: 3px dashed #e74c3c;
        border-radius: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        transition: all 0.3s;
      }

      #clear-area.hover {
        background: linear-gradient(135deg, rgba(231, 76, 60, 0.6), rgba(192, 57, 43, 0.6));
        transform: scale(1.05);
        border-style: solid;
      }

      #clear-area.active {
        background: linear-gradient(135deg, rgba(231, 76, 60, 0.9), rgba(192, 57, 43, 0.9));
        transform: scale(1.1);
      }

      #clear-area-icon {
        font-size: 50px;
        margin-bottom: 5px;
      }

      #clear-area-text {
        color: white;
        font-size: 14px;
        font-weight: bold;
        text-shadow: 1px 1px 2px black;
      }

      #clear-progress {
        width: 80%;
        height: 8px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        margin-top: 10px;
        overflow: hidden;
      }

      #clear-progress-bar {
        height: 100%;
        background: #fff;
        width: 0%;
        transition: width 0.1s;
      }

      /* ç´™ã‚ãã‚Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
      #paper-container.flipping {
        animation: flipPaper 0.6s ease-in-out;
      }

      @keyframes flipPaper {
        0% {
          transform: perspective(1000px) rotateY(0deg);
        }
        50% {
          transform: perspective(1000px) rotateY(-90deg);
        }
        100% {
          transform: perspective(1000px) rotateY(0deg);
        }
      }

      /* æ–°ã—ã„ç´™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
      .new-paper-effect {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        pointer-events: none;
        animation: newPaperFlash 0.5s ease-out forwards;
        border-radius: 4px;
      }

      @keyframes newPaperFlash {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <div class="spinner"></div>
      <p>ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...</p>
    </div>

    <div id="background"></div>

    <div id="container">
      <div id="top-banner">
        <h1>æ›¸ãåˆã‚ - ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã§æ›¸é“</h1>
      </div>

      <div id="info">
        <h2>éŠã³æ–¹</h2>
        <p>ğŸ‘Œ <strong>è¦ªæŒ‡ã¨äººå·®ã—æŒ‡ã§ã¤ã¾ã‚€</strong>ã¨ç­†ã‚’æŒã¦ã¾ã™</p>
        <p>âœï¸ <strong>ã¤ã¾ã‚“ã ã¾ã¾å‹•ã‹ã™</strong>ã¨ç´™ã«æ›¸ã‘ã¾ã™</p>
        <p>ğŸ–Œï¸ <strong>å¢¨æ±ã«è§¦ã‚Œã‚‹</strong>ã¨å¢¨ã‚’è£œå……</p>
        <p>ğŸ“„ <strong>å³ä¸‹ã§ã¤ã¾ã‚€</strong>ã¨æ¬¡ã®ç´™ã¸</p>
        <div id="status">å¾…æ©Ÿä¸­...</div>
      </div>

      <div id="video-container">
        <video id="input_video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
      </div>

      <img id="pen-cursor" src="kakizome-images/pen.png" alt="ç­†" class="hidden" />

      <div id="calligraphy-area">
        <div id="paper-container">
          <img id="paper-image" src="kakizome-images/paper.png" alt="åŠç´™" />
          <canvas id="drawing-canvas"></canvas>
        </div>
      </div>

      <div id="charcoal-container">
        <img id="charcoal-image" src="kakizome-images/charcoal.png" alt="å¢¨æ±" />
      </div>

      <div id="ink-label">å¢¨ã®é‡</div>
      <div id="ink-indicator">
        <div id="ink-level"></div>
      </div>

      <div id="pinch-indicator">ã¤ã¾ã‚“ã§ã„ã¾ã›ã‚“</div>

      <div id="brush-size-container">
        <label>ç­†ã®å¤ªã•: <span id="size-value">15</span>px</label>
        <input type="range" id="brush-size" min="5" max="40" value="15" />
      </div>

      <!-- æ‰‹ã§ã‚¯ãƒªã‚¢ã™ã‚‹ã‚¨ãƒªã‚¢ -->
      <div id="clear-area">
        <div id="clear-area-icon">ğŸ“„</div>
        <div id="clear-area-text">æ¬¡ã®ç´™ã¸</div>
        <div id="clear-progress">
          <div id="clear-progress-bar"></div>
        </div>
      </div>

      <div id="button-area">
        <button id="save-btn" class="control-btn">ä¿å­˜</button>
      </div>
    </div>

    <script type="module">
      import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

      const videoElement = document.getElementById("input_video");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const penCursor = document.getElementById("pen-cursor");
      const status = document.getElementById("status");
      const loading = document.getElementById("loading");
      const drawingCanvas = document.getElementById("drawing-canvas");
      const drawingCtx = drawingCanvas.getContext("2d");
      const paperContainer = document.getElementById("paper-container");
      const charcoalContainer = document.getElementById("charcoal-container");
      const pinchIndicator = document.getElementById("pinch-indicator");
      const inkLevel = document.getElementById("ink-level");
      const saveBtn = document.getElementById("save-btn");
      const brushSizeSlider = document.getElementById("brush-size");
      const sizeValue = document.getElementById("size-value");
      const clearArea = document.getElementById("clear-area");
      const clearProgressBar = document.getElementById("clear-progress-bar");

      let handLandmarker = null;
      let lastVideoTime = -1;

      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
      let isPinching = false;
      let lastDrawX = null;
      let lastDrawY = null;
      let inkAmount = 100; // å¢¨ã®æ®‹é‡
      let brushSize = 15;

      // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ç”¨ã®å±¥æ­´
      const positionHistory = [];
      const historySize = 5; // å¹³å‡ã‚’å–ã‚‹ç‚¹ã®æ•°
      let lastSmoothedX = null;
      let lastSmoothedY = null;
      let prevMidX = null;
      let prevMidY = null;

      // åº§æ¨™ã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
      function smoothPosition(x, y) {
        positionHistory.push({ x, y });
        if (positionHistory.length > historySize) {
          positionHistory.shift();
        }

        // åŠ é‡ç§»å‹•å¹³å‡ï¼ˆæœ€æ–°ã®å€¤ã«é‡ã¿ã‚’ç½®ãï¼‰
        let totalWeight = 0;
        let smoothedX = 0;
        let smoothedY = 0;

        positionHistory.forEach((pos, index) => {
          const weight = index + 1; // æ–°ã—ã„ã»ã©é‡ã¿å¤§
          smoothedX += pos.x * weight;
          smoothedY += pos.y * weight;
          totalWeight += weight;
        });

        return {
          x: smoothedX / totalWeight,
          y: smoothedY / totalWeight
        };
      }

      // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
      function resetSmoothing() {
        positionHistory.length = 0;
        lastSmoothedX = null;
        lastSmoothedY = null;
        prevMidX = null;
        prevMidY = null;
        lastDrawX = null;
        lastDrawY = null;
      }

      // ã‚¯ãƒªã‚¢ã‚¨ãƒªã‚¢ç”¨ã®å¤‰æ•°
      let clearProgress = 0;
      const clearThreshold = 100; // ã“ã®å€¤ã«é”ã—ãŸã‚‰ã‚¯ãƒªã‚¢
      let isClearing = false;

      // ã‚¯ãƒªã‚¢ã‚¨ãƒªã‚¢ã®ä¸Šã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
      function isOverClearArea(screenX, screenY) {
        const rect = clearArea.getBoundingClientRect();
        return (
          screenX >= rect.left &&
          screenX <= rect.right &&
          screenY >= rect.top &&
          screenY <= rect.bottom
        );
      }

      // ç´™ã‚’ã‚ãã£ã¦ã‚¯ãƒªã‚¢
      function flipAndClearPaper() {
        if (isClearing) return;
        isClearing = true;

        // ç´™ã‚ãã‚Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        paperContainer.classList.add("flipping");

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é€”ä¸­ï¼ˆç´™ãŒè£è¿”ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼‰ã§ã‚¯ãƒªã‚¢
        setTimeout(() => {
          drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
          inkAmount = 100;
          inkLevel.style.width = "100%";
          resetSmoothing();
        }, 300);

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œ
        setTimeout(() => {
          paperContainer.classList.remove("flipping");

          // æ–°ã—ã„ç´™ã®ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          const flash = document.createElement("div");
          flash.className = "new-paper-effect";
          paperContainer.appendChild(flash);
          setTimeout(() => flash.remove(), 500);

          isClearing = false;
          clearProgress = 0;
          clearProgressBar.style.width = "0%";
          clearArea.classList.remove("active");
        }, 600);
      }

      // æç”»ã‚­ãƒ£ãƒ³ãƒã‚¹ã®åˆæœŸåŒ–
      function initDrawingCanvas() {
        const rect = paperContainer.getBoundingClientRect();
        drawingCanvas.width = rect.width;
        drawingCanvas.height = rect.height;
        drawingCtx.lineCap = "round";
        drawingCtx.lineJoin = "round";
      }

      // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã«ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å†åˆæœŸåŒ–
      window.addEventListener("resize", () => {
        // ç¾åœ¨ã®æç”»å†…å®¹ã‚’ä¿å­˜
        const imageData = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
        initDrawingCanvas();
        // æç”»å†…å®¹ã‚’å¾©å…ƒ
        drawingCtx.putImageData(imageData, 0, 0);
      });

      // ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚ºå¤‰æ›´
      brushSizeSlider.addEventListener("input", (e) => {
        brushSize = parseInt(e.target.value);
        sizeValue.textContent = brushSize;
      });

      // ä¿å­˜ãƒœã‚¿ãƒ³
      saveBtn.addEventListener("click", () => {
        // åŠç´™ã¨æç”»ã‚’åˆæˆã—ã¦ä¿å­˜
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");
        const paperImage = document.getElementById("paper-image");

        tempCanvas.width = drawingCanvas.width;
        tempCanvas.height = drawingCanvas.height;

        // åŠç´™ã‚’æç”»
        tempCtx.drawImage(paperImage, 0, 0, tempCanvas.width, tempCanvas.height);
        // æ›¸ã„ãŸå†…å®¹ã‚’é‡ã­ã‚‹
        tempCtx.drawImage(drawingCanvas, 0, 0);

        // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        const link = document.createElement("a");
        link.download = "kakizome_" + new Date().toISOString().slice(0, 10) + ".png";
        link.href = tempCanvas.toDataURL("image/png");
        link.click();
      });

      // MediaPipeåˆæœŸåŒ–
      async function initializeHandLandmarker() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.7,
          minHandPresenceConfidence: 0.7,
          minTrackingConfidence: 0.7,
        });

        console.log("Hand LandmarkeråˆæœŸåŒ–å®Œäº†");
      }

      // ãƒ”ãƒ³ãƒï¼ˆã¤ã¾ã¿ï¼‰ã‚’æ¤œå‡º
      function detectPinch(landmarks) {
        // è¦ªæŒ‡ã®å…ˆç«¯ (landmark 4)
        const thumbTip = landmarks[4];
        // äººå·®ã—æŒ‡ã®å…ˆç«¯ (landmark 8)
        const indexTip = landmarks[8];

        // 2ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—
        const distance = Math.sqrt(
          Math.pow(thumbTip.x - indexTip.x, 2) +
            Math.pow(thumbTip.y - indexTip.y, 2) +
            Math.pow(thumbTip.z - indexTip.z, 2)
        );

        // é–¾å€¤ï¼ˆèª¿æ•´å¯èƒ½ï¼‰
        const pinchThreshold = 0.06;

        return distance < pinchThreshold;
      }

      // ã¤ã¾ã¿ä½ç½®ï¼ˆè¦ªæŒ‡ã¨äººå·®ã—æŒ‡ã®ä¸­ç‚¹ï¼‰ã‚’å–å¾—
      function getPinchPosition(landmarks) {
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];

        return {
          x: (thumbTip.x + indexTip.x) / 2,
          y: (thumbTip.y + indexTip.y) / 2,
        };
      }

      // ç´™ã®ä¸Šã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
      function isOverPaper(screenX, screenY) {
        const paperRect = paperContainer.getBoundingClientRect();
        return (
          screenX >= paperRect.left &&
          screenX <= paperRect.right &&
          screenY >= paperRect.top &&
          screenY <= paperRect.bottom
        );
      }

      // å¢¨æ±ã®ä¸Šã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
      function isOverCharcoal(screenX, screenY) {
        const charcoalRect = charcoalContainer.getBoundingClientRect();
        return (
          screenX >= charcoalRect.left &&
          screenX <= charcoalRect.right &&
          screenY >= charcoalRect.top &&
          screenY <= charcoalRect.bottom
        );
      }

      // ç´™ä¸Šã®åº§æ¨™ã«å¤‰æ›
      function screenToPaperCoords(screenX, screenY) {
        const paperRect = paperContainer.getBoundingClientRect();
        return {
          x: screenX - paperRect.left,
          y: screenY - paperRect.top,
        };
      }

      // å¢¨ã§ç·šã‚’æãï¼ˆã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ï¼†ãƒ™ã‚¸ã‚§æ›²ç·šï¼‰
      function drawInk(rawX, rawY) {
        if (inkAmount <= 0) return;

        // åº§æ¨™ã‚’ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
        const smoothed = smoothPosition(rawX, rawY);
        const x = smoothed.x;
        const y = smoothed.y;

        const opacity = Math.min(1, inkAmount / 30);
        const size = brushSize;

        drawingCtx.strokeStyle = `rgba(20, 20, 20, ${opacity})`;
        drawingCtx.lineWidth = size;

        if (lastSmoothedX !== null && lastSmoothedY !== null) {
          // ä¸­ç‚¹ã‚’è¨ˆç®—ã—ã¦ãƒ™ã‚¸ã‚§æ›²ç·šã§æ»‘ã‚‰ã‹ã«æç”»
          const midX = (lastSmoothedX + x) / 2;
          const midY = (lastSmoothedY + y) / 2;

          if (prevMidX !== null && prevMidY !== null) {
            // äºŒæ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šã§å‰ã®ä¸­ç‚¹ã‹ã‚‰ç¾åœ¨ã®ä¸­ç‚¹ã¸æç”»
            drawingCtx.beginPath();
            drawingCtx.moveTo(prevMidX, prevMidY);
            drawingCtx.quadraticCurveTo(lastSmoothedX, lastSmoothedY, midX, midY);
            drawingCtx.stroke();
          } else {
            // æœ€åˆã®ç·šã¯ç›´ç·šã§
            drawingCtx.beginPath();
            drawingCtx.moveTo(lastSmoothedX, lastSmoothedY);
            drawingCtx.lineTo(midX, midY);
            drawingCtx.stroke();
          }

          prevMidX = midX;
          prevMidY = midY;
        }

        lastSmoothedX = x;
        lastSmoothedY = y;
        lastDrawX = x;
        lastDrawY = y;

        // å¢¨ã‚’æ¶ˆè²»ï¼ˆå°‘ã—æ¸›ã‚‰ã™ï¼‰
        inkAmount = Math.max(0, inkAmount - 0.15);
        inkLevel.style.width = `${inkAmount}%`;
      }

      // æ‰‹ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’å‡¦ç†
      function processHandLandmarks(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.landmarks && results.landmarks.length > 0) {
          const landmarks = results.landmarks[0];

          // æ‰‹ã®éª¨æ ¼ã‚’æç”»
          drawHandSkeleton(landmarks);

          // ãƒ”ãƒ³ãƒæ¤œå‡º
          const currentPinching = detectPinch(landmarks);
          const pinchPos = getPinchPosition(landmarks);

          // ç”»é¢åº§æ¨™ã«å¤‰æ›ï¼ˆãƒŸãƒ©ãƒ¼åè»¢ï¼‰
          const screenX = (1.0 - pinchPos.x) * window.innerWidth;
          const screenY = pinchPos.y * window.innerHeight;

          // ç­†ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•
          penCursor.style.left = `${screenX}px`;
          penCursor.style.top = `${screenY}px`;
          penCursor.classList.remove("hidden");

          if (currentPinching) {
            penCursor.classList.add("active");
            pinchIndicator.textContent = "ã¤ã¾ã‚“ã§ã„ã¾ã™ï¼âœï¸";
            pinchIndicator.classList.add("show", "pinching");

            // ã‚¯ãƒªã‚¢ã‚¨ãƒªã‚¢ã®ä¸Šã«ã„ã‚‹ã¨ã
            if (isOverClearArea(screenX, screenY) && !isClearing) {
              clearArea.classList.add("hover");
              clearProgress += 3;
              clearProgressBar.style.width = `${Math.min(100, clearProgress)}%`;
              status.textContent = `æ¬¡ã®ç´™ã¸... (${Math.min(100, Math.floor(clearProgress))}%)`;
              status.className = "writing";
              resetSmoothing();

              if (clearProgress >= clearThreshold) {
                clearArea.classList.add("active");
                flipAndClearPaper();
              }
            }
            // å¢¨æ±ã®ä¸Šã«ã„ã‚‹ã¨ã
            else if (isOverCharcoal(screenX, screenY)) {
              clearArea.classList.remove("hover");
              clearProgress = 0;
              clearProgressBar.style.width = "0%";
              inkAmount = Math.min(100, inkAmount + 2);
              inkLevel.style.width = `${inkAmount}%`;
              status.textContent = "å¢¨ã‚’è£œå……ä¸­...";
              status.className = "active";
              resetSmoothing();
            }
            // ç´™ã®ä¸Šã«ã„ã‚‹ã¨ã
            else if (isOverPaper(screenX, screenY)) {
              clearArea.classList.remove("hover");
              clearProgress = 0;
              clearProgressBar.style.width = "0%";
              const paperCoords = screenToPaperCoords(screenX, screenY);
              drawInk(paperCoords.x, paperCoords.y);

              if (inkAmount > 0) {
                status.textContent = `æ›¸ã„ã¦ã„ã¾ã™... (å¢¨: ${Math.floor(inkAmount)}%)`;
                status.className = "writing";
              } else {
                status.textContent = "å¢¨ãŒã‚ã‚Šã¾ã›ã‚“ï¼å¢¨æ±ã«ã¤ã‘ã¦ãã ã•ã„";
                status.className = "";
              }
            } else {
              clearArea.classList.remove("hover");
              clearProgress = 0;
              clearProgressBar.style.width = "0%";
              status.textContent = "ç´™ã®ä¸Šã«ç§»å‹•ã—ã¦ãã ã•ã„";
              status.className = "active";
              resetSmoothing();
            }
          } else {
            penCursor.classList.remove("active");
            pinchIndicator.textContent = "ã¤ã¾ã‚“ã§ã„ã¾ã›ã‚“";
            pinchIndicator.classList.add("show");
            pinchIndicator.classList.remove("pinching");

            // ã¤ã¾ã¿ã‚’é›¢ã—ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
            if (isPinching) {
              resetSmoothing();
              clearArea.classList.remove("hover");
              clearProgress = 0;
              clearProgressBar.style.width = "0%";
            }

            if (isOverPaper(screenX, screenY)) {
              status.textContent = "ã¤ã¾ã‚“ã§æ›¸ãå§‹ã‚ã¾ã—ã‚‡ã†ï¼";
              status.className = "";
            } else if (isOverClearArea(screenX, screenY)) {
              status.textContent = "ã¤ã¾ã‚“ã§æ¬¡ã®ç´™ã¸";
              status.className = "";
            } else {
              status.textContent = "ç´™ã®ä¸Šã§æŒ‡ã‚’ã¤ã¾ã‚€ã¨æ›¸ã‘ã¾ã™";
              status.className = "";
            }
          }

          isPinching = currentPinching;
        } else {
          penCursor.classList.add("hidden");
          pinchIndicator.classList.remove("show");
          status.textContent = "æ‰‹ãŒè¦‹ãˆã¾ã›ã‚“...";
          status.className = "";
          resetSmoothing();
        }

        canvasCtx.restore();
      }

      // æ‰‹ã®éª¨æ ¼ã‚’æç”»
      function drawHandSkeleton(landmarks) {
        canvasCtx.strokeStyle = "#8b4513";
        canvasCtx.lineWidth = 2;

        const connections = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 4],
          [0, 5],
          [5, 6],
          [6, 7],
          [7, 8],
          [0, 9],
          [9, 10],
          [10, 11],
          [11, 12],
          [0, 13],
          [13, 14],
          [14, 15],
          [15, 16],
          [0, 17],
          [17, 18],
          [18, 19],
          [19, 20],
          [5, 9],
          [9, 13],
          [13, 17],
        ];

        connections.forEach(([start, end]) => {
          const startPoint = landmarks[start];
          const endPoint = landmarks[end];
          canvasCtx.beginPath();
          canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
          canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
          canvasCtx.stroke();
        });

        landmarks.forEach((landmark, index) => {
          const x = landmark.x * canvasElement.width;
          const y = landmark.y * canvasElement.height;
          canvasCtx.beginPath();
          canvasCtx.arc(x, y, index === 4 || index === 8 ? 6 : 4, 0, 2 * Math.PI);
          canvasCtx.fillStyle = index === 4 || index === 8 ? "#ffd700" : "#8b4513";
          canvasCtx.fill();
        });
      }

      // ã‚«ãƒ¡ãƒ©èµ·å‹•
      async function startCamera() {
        await initializeHandLandmarker();

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“";
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
          });
          videoElement.srcObject = stream;

          videoElement.addEventListener("loadeddata", () => {
            loading.classList.add("hidden");
            initDrawingCanvas();
            console.log("ã‚«ãƒ¡ãƒ©èµ·å‹•å®Œäº†");

            function onFrame() {
              if (!handLandmarker) return;

              const startTimeMs = performance.now();

              if (videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                processHandLandmarks(results);
              }

              requestAnimationFrame(onFrame);
            }
            onFrame();
          });
        } catch (error) {
          console.error("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼:", error);
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—: " + error.message;
        }
      }

      startCamera();
    </script>
  </body>
</html>
