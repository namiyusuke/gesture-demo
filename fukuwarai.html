<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ç¦ç¬‘ã„ã‚²ãƒ¼ãƒ </title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      h1 {
        color: white;
        text-align: center;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      }

      .main-area {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
      }

      /* ã‚«ãƒ¡ãƒ©ã‚¨ãƒªã‚¢ */
      .camera-section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }

      .camera-section h2 {
        color: #ff6b6b;
        margin-bottom: 15px;
      }

      #video-container {
        position: relative;
        width: 320px;
        height: 240px;
        border: 3px solid #ff6b6b;
        border-radius: 12px;
        overflow: hidden;
        background: #000;
      }

      #input_video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      /* æ‰‹ã®ã‚«ãƒ¼ã‚½ãƒ« */
      #hand-cursor {
        position: fixed;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background: rgba(255, 100, 100, 0.8);
        border: 3px solid white;
        pointer-events: none;
        z-index: 9999;
        transform: translate(-50%, -50%);
        transition: background 0.2s, transform 0.1s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        display: none;
      }

      #hand-cursor.pinching {
        background: rgba(100, 255, 100, 0.9);
        transform: translate(-50%, -50%) scale(1.3);
      }

      #capture-btn {
        display: block;
        width: 100%;
        padding: 12px;
        margin-top: 15px;
        background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }

      #capture-btn:hover {
        transform: translateY(-2px);
      }

      #status {
        margin-top: 10px;
        padding: 8px;
        background: #f0f0f0;
        border-radius: 6px;
        text-align: center;
        font-size: 14px;
      }

      #status.active {
        background: #d4edda;
        color: #155724;
      }

      /* æ“ä½œãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ */
      .mode-switch {
        margin-top: 15px;
        display: flex;
        gap: 10px;
      }

      .mode-switch button {
        flex: 1;
        padding: 10px;
        border: 2px solid #ff6b6b;
        border-radius: 8px;
        background: white;
        color: #ff6b6b;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
      }

      .mode-switch button.active {
        background: #ff6b6b;
        color: white;
      }

      /* ç¦ç¬‘ã„ã‚¨ãƒªã‚¢ */
      .fukuwarai-section {
        flex: 1;
        min-width: 500px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }

      .fukuwarai-section h2 {
        color: #ff6b6b;
        margin-bottom: 15px;
      }

      /* ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º */
      .game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      #timer {
        font-size: 32px;
        font-weight: bold;
        color: #ff6b6b;
        background: #fff0f0;
        padding: 10px 20px;
        border-radius: 12px;
      }

      #timer.warning {
        color: #dc3545;
        animation: pulse 0.5s infinite;
      }

      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
      }

      #start-game-btn {
        padding: 15px 30px;
        background: linear-gradient(135deg, #6bcb77 0%, #4caf50 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }

      #start-game-btn:hover {
        transform: translateY(-2px);
      }

      #start-game-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .fukuwarai-container {
        display: flex;
        gap: 20px;
      }

      /* é¡”ã®è¼ªéƒ­ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ï¼‰ */
      #face-canvas {
        width: 400px;
        height: 500px;
        border: 3px dashed #ffb6c1;
        border-radius: 50%;
        background: #fff5f5;
        position: relative;
        overflow: hidden;
      }

      /* é¡”ã‚¬ã‚¤ãƒ‰ï¼ˆã¼ã‚“ã‚„ã‚Šè¡¨ç¤ºï¼‰ */
      #face-guide {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.15;
        pointer-events: none;
      }

      /* ãƒ‘ãƒ¼ãƒ„ç½®ãå ´ */
      .parts-tray {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 15px;
        background: #fff0f0;
        border-radius: 12px;
        min-width: 150px;
      }

      .parts-tray h3 {
        font-size: 14px;
        color: #666;
        text-align: center;
        margin-bottom: 5px;
      }

      /* ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªãƒ‘ãƒ¼ãƒ„ */
      .draggable-part {
        cursor: grab;
        border: 2px solid #ffb6c1;
        border-radius: 8px;
        background: white;
        padding: 5px;
        text-align: center;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .draggable-part:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }

      .draggable-part.dragging {
        opacity: 0.8;
        cursor: grabbing;
        z-index: 1000;
      }

      .draggable-part canvas {
        display: block;
        max-width: 100%;
      }

      .draggable-part span {
        font-size: 12px;
        color: #666;
      }

      /* é¡”ã®ä¸Šã«é…ç½®ã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ„ */
      .placed-part {
        position: absolute;
        cursor: grab;
        transition: box-shadow 0.2s;
      }

      .placed-part:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      }

      .placed-part.dragging {
        cursor: grabbing;
        z-index: 1000;
      }

      /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
      .controls {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .controls button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .controls button:hover {
        transform: translateY(-2px);
      }

      #reset-btn {
        background: #ffd93d;
        color: #333;
      }

      #save-btn {
        background: #6bcb77;
        color: white;
      }

      #shuffle-btn {
        background: #4d96ff;
        color: white;
      }

      /* ã‚¹ã‚³ã‚¢è¡¨ç¤º */
      #score-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 10001;
        justify-content: center;
        align-items: center;
      }

      #score-modal.show {
        display: flex;
      }

      .score-content {
        background: white;
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        max-width: 400px;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      .score-content h2 {
        color: #ff6b6b;
        margin-bottom: 20px;
        font-size: 28px;
      }

      .score-value {
        font-size: 72px;
        font-weight: bold;
        color: #4caf50;
        margin: 20px 0;
      }

      .score-rank {
        font-size: 48px;
        margin: 10px 0;
      }

      .score-detail {
        color: #666;
        margin: 10px 0;
        font-size: 14px;
      }

      .score-content button {
        margin-top: 20px;
        padding: 15px 40px;
        background: #ff6b6b;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
      }

      /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        text-align: center;
        z-index: 10000;
      }

      #loading.hidden {
        display: none;
      }

      .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #ff6b6b;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .instructions {
        background: #fff3cd;
        padding: 10px 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        font-size: 14px;
        color: #856404;
      }

      /* æ™‚é–“è¨­å®š */
      .time-setting {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }

      .time-setting label {
        font-size: 14px;
        color: #666;
      }

      .time-setting select {
        padding: 8px 12px;
        border: 2px solid #ffb6c1;
        border-radius: 8px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <div class="spinner"></div>
      <p>ã‚«ãƒ¡ãƒ©ã¨MediaPipeã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
    </div>

    <!-- æ‰‹ã®ã‚«ãƒ¼ã‚½ãƒ« -->
    <div id="hand-cursor"></div>

    <!-- ã‚¹ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="score-modal">
      <div class="score-content">
        <h2>çµæœç™ºè¡¨ï¼</h2>
        <div class="score-rank" id="score-rank"></div>
        <div class="score-value" id="score-value">0</div>
        <div class="score-detail" id="score-detail"></div>
        <button id="close-score">ã‚‚ã†ä¸€åº¦éŠã¶</button>
      </div>
    </div>

    <div class="container">
      <h1>ğŸ­ ç¦ç¬‘ã„ã‚²ãƒ¼ãƒ </h1>

      <div class="main-area">
        <!-- ã‚«ãƒ¡ãƒ©ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="camera-section">
          <h2>ğŸ“· é¡”ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£</h2>
          <div id="video-container">
            <video id="input_video" autoplay playsinline></video>
            <canvas id="output_canvas"></canvas>
          </div>
          <button id="capture-btn">ğŸ“¸ ãƒ‘ãƒ¼ãƒ„ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£</button>
          <div id="status">å¾…æ©Ÿä¸­...</div>

          <!-- æ“ä½œãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ -->
          <div class="mode-switch">
            <button id="mode-mouse" class="active">ğŸ–± ãƒã‚¦ã‚¹</button>
            <button id="mode-hand">âœ‹ æ‰‹ã§æ“ä½œ</button>
          </div>

          <!-- æ™‚é–“è¨­å®š -->
          <div class="time-setting">
            <label>åˆ¶é™æ™‚é–“:</label>
            <select id="time-select">
              <option value="30">30ç§’</option>
              <option value="60" selected>60ç§’</option>
              <option value="90">90ç§’</option>
              <option value="0">ç„¡åˆ¶é™</option>
            </select>
          </div>
        </div>

        <!-- ç¦ç¬‘ã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="fukuwarai-section">
          <div class="game-header">
            <h2>ğŸ¯ ç¦ç¬‘ã„ã§éŠã¼ã†</h2>
            <div id="timer">--:--</div>
            <button id="start-game-btn" disabled>ğŸ® ã‚²ãƒ¼ãƒ é–‹å§‹</button>
          </div>
          <div class="instructions" id="instructions">
            ğŸ’¡ 1. ã¾ãšé¡”ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ â†’ 2. ã‚²ãƒ¼ãƒ é–‹å§‹ â†’ 3. ãƒ‘ãƒ¼ãƒ„ã‚’æ­£ã—ã„ä½ç½®ã«é…ç½®ï¼
          </div>
          <div class="fukuwarai-container">
            <!-- ãƒ‘ãƒ¼ãƒ„ç½®ãå ´ -->
            <div class="parts-tray" id="parts-tray">
              <h3>ãƒ‘ãƒ¼ãƒ„</h3>
              <div class="draggable-part" data-part="leftEye">
                <canvas id="tray-left-eye" width="80" height="40"></canvas>
                <span>å·¦ç›®</span>
              </div>
              <div class="draggable-part" data-part="rightEye">
                <canvas id="tray-right-eye" width="80" height="40"></canvas>
                <span>å³ç›®</span>
              </div>
              <div class="draggable-part" data-part="nose">
                <canvas id="tray-nose" width="60" height="60"></canvas>
                <span>é¼»</span>
              </div>
              <div class="draggable-part" data-part="mouth">
                <canvas id="tray-mouth" width="80" height="40"></canvas>
                <span>å£</span>
              </div>
              <div class="draggable-part" data-part="leftEyebrow">
                <canvas id="tray-left-eyebrow" width="80" height="30"></canvas>
                <span>å·¦çœ‰</span>
              </div>
              <div class="draggable-part" data-part="rightEyebrow">
                <canvas id="tray-right-eyebrow" width="80" height="30"></canvas>
                <span>å³çœ‰</span>
              </div>
            </div>

            <!-- é¡”ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
            <div id="face-canvas">
              <canvas id="face-guide"></canvas>
            </div>
          </div>

          <div class="controls">
            <button id="shuffle-btn">ğŸ² ã‚·ãƒ£ãƒƒãƒ•ãƒ«é…ç½®</button>
            <button id="reset-btn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
            <button id="save-btn">ğŸ’¾ ç”»åƒã‚’ä¿å­˜</button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { FilesetResolver, FaceLandmarker, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

      const videoElement = document.getElementById("input_video");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const status = document.getElementById("status");
      const loading = document.getElementById("loading");
      const captureBtn = document.getElementById("capture-btn");
      const faceCanvas = document.getElementById("face-canvas");
      const faceGuide = document.getElementById("face-guide");
      const faceGuideCtx = faceGuide.getContext("2d");
      const handCursor = document.getElementById("hand-cursor");
      const timerDisplay = document.getElementById("timer");
      const startGameBtn = document.getElementById("start-game-btn");
      const scoreModal = document.getElementById("score-modal");
      const instructions = document.getElementById("instructions");

      // ãƒ‘ãƒ¼ãƒ„ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹
      const trayCanvases = {
        leftEye: document.getElementById("tray-left-eye"),
        rightEye: document.getElementById("tray-right-eye"),
        nose: document.getElementById("tray-nose"),
        mouth: document.getElementById("tray-mouth"),
        leftEyebrow: document.getElementById("tray-left-eyebrow"),
        rightEyebrow: document.getElementById("tray-right-eyebrow"),
      };

      let faceLandmarker = null;
      let handLandmarker = null;
      let lastVideoTime = -1;
      let currentLandmarks = null;
      let correctPositions = {}; // æ­£è§£ã®ä½ç½®ã‚’ä¿å­˜
      let placedParts = [];
      let isHandMode = false;
      let isGameRunning = false;
      let gameTimer = null;
      let remainingTime = 60;

      // æ‰‹æ“ä½œç”¨ã®å¤‰æ•°
      let smoothX = window.innerWidth / 2;
      let smoothY = window.innerHeight / 2;
      const smoothFactor = 0.3;
      let isPinching = false;
      let handDraggedPart = null;
      let handOffsetX = 0;
      let handOffsetY = 0;

      // FaceMeshã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
      const FACE_PARTS = {
        leftEye: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246],
        rightEye: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398],
        nose: [1, 2, 98, 327, 168, 6, 197, 195, 5, 4, 19, 94, 370],
        mouth: [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95],
        leftEyebrow: [70, 63, 105, 66, 107, 55, 65, 52, 53, 46],
        rightEyebrow: [300, 293, 334, 296, 336, 285, 295, 282, 283, 276],
      };

      // MediaPipeåˆæœŸåŒ–
      async function initializeMediaPipe() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        // Face Landmarker
        faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numFaces: 1,
          minFaceDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        // Hand Landmarker
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.7,
          minHandPresenceConfidence: 0.7,
          minTrackingConfidence: 0.7,
        });

        console.log("MediaPipeåˆæœŸåŒ–å®Œäº†");
      }

      // ãƒ‘ãƒ¼ãƒ„ã®ç¯„å›²ã‚’è¨ˆç®—
      function getPartBounds(landmarks, indices, padding = 15) {
        const points = indices.map((i) => landmarks[i]);
        const xs = points.map((p) => p.x * videoElement.videoWidth);
        const ys = points.map((p) => p.y * videoElement.videoHeight);

        return {
          minX: Math.max(0, Math.min(...xs) - padding),
          maxX: Math.min(videoElement.videoWidth, Math.max(...xs) + padding),
          minY: Math.max(0, Math.min(...ys) - padding),
          maxY: Math.min(videoElement.videoHeight, Math.max(...ys) + padding),
        };
      }

      // ãƒ‘ãƒ¼ãƒ„ã®ä¸­å¿ƒåº§æ¨™ã‚’è¨ˆç®—ï¼ˆæ­£è§£ä½ç½®ç”¨ï¼‰
      function getPartCenter(landmarks, indices) {
        const points = indices.map((i) => landmarks[i]);
        const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
        return { x: avgX, y: avgY };
      }

      // ãƒ‘ãƒ¼ãƒ„ã‚’åˆ‡ã‚Šå‡ºã—ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
      function extractPart(landmarks, partName, indices) {
        const canvas = trayCanvases[partName];
        const ctx = canvas.getContext("2d");
        const bounds = getPartBounds(landmarks, indices);

        const width = bounds.maxX - bounds.minX;
        const height = bounds.maxY - bounds.minY;

        const mirroredX = videoElement.videoWidth - bounds.maxX;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(
          videoElement,
          mirroredX, bounds.minY, width, height,
          0, 0, canvas.width, canvas.height
        );

        // æ­£è§£ä½ç½®ã‚’ä¿å­˜ï¼ˆface-canvasåº§æ¨™ç³»ã«å¤‰æ›ï¼‰
        const center = getPartCenter(landmarks, indices);
        correctPositions[partName] = {
          x: (1 - center.x) * faceCanvas.offsetWidth,
          y: center.y * faceCanvas.offsetHeight,
        };
      }

      // é¡”ã®ã‚¬ã‚¤ãƒ‰ã‚’æç”»
      function drawFaceGuide(landmarks) {
        faceGuide.width = faceCanvas.offsetWidth;
        faceGuide.height = faceCanvas.offsetHeight;

        faceGuideCtx.clearRect(0, 0, faceGuide.width, faceGuide.height);

        // é¡”ã®è¼ªéƒ­ã‚’æç”»
        const faceOutline = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];

        faceGuideCtx.strokeStyle = "#ffb6c1";
        faceGuideCtx.lineWidth = 3;
        faceGuideCtx.beginPath();

        faceOutline.forEach((index, i) => {
          const x = (1 - landmarks[index].x) * faceGuide.width;
          const y = landmarks[index].y * faceGuide.height;
          if (i === 0) {
            faceGuideCtx.moveTo(x, y);
          } else {
            faceGuideCtx.lineTo(x, y);
          }
        });
        faceGuideCtx.closePath();
        faceGuideCtx.stroke();

        // ãƒ‘ãƒ¼ãƒ„ã®æ­£è§£ä½ç½®ã‚’ã¼ã‚“ã‚„ã‚Šè¡¨ç¤º
        Object.entries(FACE_PARTS).forEach(([partName, indices]) => {
          const center = getPartCenter(landmarks, indices);
          const x = (1 - center.x) * faceGuide.width;
          const y = center.y * faceGuide.height;

          faceGuideCtx.fillStyle = "rgba(255, 182, 193, 0.3)";
          faceGuideCtx.beginPath();
          faceGuideCtx.ellipse(x, y, 30, 20, 0, 0, Math.PI * 2);
          faceGuideCtx.fill();
        });
      }

      // é¡”ã¨æ‰‹ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’å‡¦ç†
      function processResults(faceResults, handResults) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        // é¡”ã®æ¤œå‡º
        if (faceResults.faceLandmarks && faceResults.faceLandmarks.length > 0) {
          const landmarks = faceResults.faceLandmarks[0];
          currentLandmarks = landmarks;

          canvasCtx.fillStyle = "rgba(0, 255, 0, 0.5)";
          landmarks.forEach((landmark) => {
            const x = landmark.x * canvasElement.width;
            const y = landmark.y * canvasElement.height;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 1, 0, 2 * Math.PI);
            canvasCtx.fill();
          });

          status.textContent = "é¡”ã‚’æ¤œå‡ºä¸­ âœ“";
          status.classList.add("active");
        } else {
          currentLandmarks = null;
          status.textContent = "é¡”ãŒè¦‹ãˆã¾ã›ã‚“...";
          status.classList.remove("active");
        }

        // æ‰‹ã®æ¤œå‡ºï¼ˆæ‰‹ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆï¼‰
        if (isHandMode && handResults.landmarks && handResults.landmarks.length > 0) {
          const handLandmarks = handResults.landmarks[0];

          // æ‰‹ã®éª¨æ ¼ã‚’æç”»
          canvasCtx.strokeStyle = "#00ff00";
          canvasCtx.lineWidth = 2;

          const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17],
          ];

          connections.forEach(([start, end]) => {
            const startPoint = handLandmarks[start];
            const endPoint = handLandmarks[end];
            canvasCtx.beginPath();
            canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
            canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
            canvasCtx.stroke();
          });

          // äººå·®ã—æŒ‡ã®å…ˆç«¯ã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã™
          const indexFingerTip = handLandmarks[8];
          const targetX = (1.0 - indexFingerTip.x) * window.innerWidth;
          const targetY = indexFingerTip.y * window.innerHeight;

          smoothX += (targetX - smoothX) * smoothFactor;
          smoothY += (targetY - smoothY) * smoothFactor;

          handCursor.style.left = `${smoothX}px`;
          handCursor.style.top = `${smoothY}px`;
          handCursor.style.display = "block";

          // ãƒ”ãƒ³ãƒã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ¤œå‡º
          const thumbTip = handLandmarks[4];
          const distance = Math.sqrt(
            Math.pow(indexFingerTip.x - thumbTip.x, 2) +
            Math.pow(indexFingerTip.y - thumbTip.y, 2) +
            Math.pow(indexFingerTip.z - thumbTip.z, 2)
          );

          if (distance < 0.06) {
            if (!isPinching) {
              isPinching = true;
              handCursor.classList.add("pinching");

              // ãƒ‘ãƒ¼ãƒ„ã‚’æ´ã‚€
              const element = document.elementFromPoint(smoothX, smoothY);
              if (element && element.classList.contains("placed-part")) {
                handDraggedPart = element;
                const rect = element.getBoundingClientRect();
                handOffsetX = smoothX - rect.left;
                handOffsetY = smoothY - rect.top;
              } else if (element && element.closest(".draggable-part")) {
                // ãƒˆãƒ¬ã‚¤ã‹ã‚‰ãƒ‘ãƒ¼ãƒ„ã‚’å–ã‚‹
                const partElement = element.closest(".draggable-part");
                const partName = partElement.dataset.part;
                createPlacedPart(partName, smoothX, smoothY);
              }
            }

            // ãƒ‰ãƒ©ãƒƒã‚°ä¸­
            if (handDraggedPart) {
              const faceRect = faceCanvas.getBoundingClientRect();
              handDraggedPart.style.left = (smoothX - faceRect.left - handOffsetX) + "px";
              handDraggedPart.style.top = (smoothY - faceRect.top - handOffsetY) + "px";
            }
          } else {
            isPinching = false;
            handCursor.classList.remove("pinching");
            handDraggedPart = null;
          }
        } else if (isHandMode) {
          handCursor.style.display = "none";
        }

        canvasCtx.restore();
      }

      // é…ç½®ãƒ‘ãƒ¼ãƒ„ã‚’ä½œæˆ
      function createPlacedPart(partName, x, y) {
        const canvas = trayCanvases[partName];
        const img = document.createElement("img");
        img.src = canvas.toDataURL();
        img.className = "placed-part";
        img.dataset.part = partName;
        img.style.width = canvas.width + "px";
        img.style.height = canvas.height + "px";

        const faceRect = faceCanvas.getBoundingClientRect();
        img.style.left = (x - faceRect.left - canvas.width / 2) + "px";
        img.style.top = (y - faceRect.top - canvas.height / 2) + "px";

        faceCanvas.appendChild(img);
        placedParts.push(img);

        if (!isHandMode) {
          setupPlacedPartDrag(img);
        }

        if (isHandMode) {
          handDraggedPart = img;
          handOffsetX = canvas.width / 2;
          handOffsetY = canvas.height / 2;
        }
      }

      // ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒœã‚¿ãƒ³
      captureBtn.addEventListener("click", () => {
        if (!currentLandmarks) {
          alert("é¡”ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“");
          return;
        }

        // å„ãƒ‘ãƒ¼ãƒ„ã‚’åˆ‡ã‚Šå‡ºã—
        Object.entries(FACE_PARTS).forEach(([partName, indices]) => {
          extractPart(currentLandmarks, partName, indices);
        });

        // é¡”ã‚¬ã‚¤ãƒ‰ã‚’æç”»
        drawFaceGuide(currentLandmarks);

        startGameBtn.disabled = false;
        status.textContent = "ã‚­ãƒ£ãƒ—ãƒãƒ£å®Œäº†ï¼ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã‚ˆã†";
        instructions.textContent = "âœ… ã‚­ãƒ£ãƒ—ãƒãƒ£å®Œäº†ï¼ã€Œã‚²ãƒ¼ãƒ é–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆï¼";
      });

      // ã‚²ãƒ¼ãƒ é–‹å§‹
      startGameBtn.addEventListener("click", () => {
        if (isGameRunning) return;

        // ãƒªã‚»ãƒƒãƒˆ
        placedParts.forEach(p => p.remove());
        placedParts = [];

        isGameRunning = true;
        startGameBtn.disabled = true;

        const selectedTime = parseInt(document.getElementById("time-select").value);
        remainingTime = selectedTime;

        if (selectedTime > 0) {
          updateTimerDisplay();
          gameTimer = setInterval(() => {
            remainingTime--;
            updateTimerDisplay();

            if (remainingTime <= 10) {
              timerDisplay.classList.add("warning");
            }

            if (remainingTime <= 0) {
              endGame();
            }
          }, 1000);
        } else {
          timerDisplay.textContent = "âˆ";
        }

        instructions.textContent = "ğŸ® ã‚²ãƒ¼ãƒ ä¸­ï¼ãƒ‘ãƒ¼ãƒ„ã‚’æ­£ã—ã„ä½ç½®ã«é…ç½®ã—ã‚ˆã†ï¼";
      });

      function updateTimerDisplay() {
        const minutes = Math.floor(remainingTime / 60);
        const seconds = remainingTime % 60;
        timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      }

      function endGame() {
        isGameRunning = false;
        clearInterval(gameTimer);
        startGameBtn.disabled = false;
        timerDisplay.classList.remove("warning");

        // ã‚¹ã‚³ã‚¢è¨ˆç®—
        calculateScore();
      }

      // ã‚¹ã‚³ã‚¢è¨ˆç®—
      function calculateScore() {
        let totalScore = 0;
        let details = [];

        const maxDistance = Math.sqrt(
          Math.pow(faceCanvas.offsetWidth, 2) +
          Math.pow(faceCanvas.offsetHeight, 2)
        );

        Object.keys(FACE_PARTS).forEach((partName) => {
          const placedPart = placedParts.find(p => p.dataset.part === partName);
          const correct = correctPositions[partName];

          if (placedPart && correct) {
            const partX = parseInt(placedPart.style.left) + parseInt(placedPart.style.width) / 2;
            const partY = parseInt(placedPart.style.top) + parseInt(placedPart.style.height) / 2;

            const distance = Math.sqrt(
              Math.pow(partX - correct.x, 2) +
              Math.pow(partY - correct.y, 2)
            );

            const partScore = Math.max(0, Math.round(100 * (1 - distance / (maxDistance * 0.3))));
            totalScore += partScore;

            details.push(`${partName}: ${partScore}ç‚¹`);
          } else {
            details.push(`${partName}: æœªé…ç½®`);
          }
        });

        const averageScore = Math.round(totalScore / Object.keys(FACE_PARTS).length);

        // ãƒ©ãƒ³ã‚¯åˆ¤å®š
        let rank = "";
        if (averageScore >= 90) rank = "ğŸ† S";
        else if (averageScore >= 80) rank = "ğŸ¥‡ A";
        else if (averageScore >= 70) rank = "ğŸ¥ˆ B";
        else if (averageScore >= 60) rank = "ğŸ¥‰ C";
        else rank = "ğŸ˜… D";

        document.getElementById("score-value").textContent = averageScore;
        document.getElementById("score-rank").textContent = rank;
        document.getElementById("score-detail").innerHTML = details.join("<br>");
        scoreModal.classList.add("show");
      }

      // ã‚¹ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
      document.getElementById("close-score").addEventListener("click", () => {
        scoreModal.classList.remove("show");
        timerDisplay.textContent = "--:--";
      });

      // æ“ä½œãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
      document.getElementById("mode-mouse").addEventListener("click", () => {
        isHandMode = false;
        document.getElementById("mode-mouse").classList.add("active");
        document.getElementById("mode-hand").classList.remove("active");
        handCursor.style.display = "none";
      });

      document.getElementById("mode-hand").addEventListener("click", () => {
        isHandMode = true;
        document.getElementById("mode-hand").classList.add("active");
        document.getElementById("mode-mouse").classList.remove("active");
      });

      // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ï¼ˆãƒã‚¦ã‚¹ç”¨ï¼‰
      function setupDragAndDrop() {
        const draggableParts = document.querySelectorAll(".draggable-part");

        draggableParts.forEach((part) => {
          part.addEventListener("mousedown", startDrag);
          part.addEventListener("touchstart", startDrag, { passive: false });
        });

        function startDrag(e) {
          if (isHandMode) return;
          e.preventDefault();
          const partElement = e.currentTarget;
          const partName = partElement.dataset.part;
          const canvas = trayCanvases[partName];

          const newPart = document.createElement("img");
          newPart.src = canvas.toDataURL();
          newPart.className = "placed-part dragging";
          newPart.dataset.part = partName;
          newPart.style.width = canvas.width + "px";
          newPart.style.height = canvas.height + "px";

          faceCanvas.appendChild(newPart);
          placedParts.push(newPart);

          const rect = faceCanvas.getBoundingClientRect();
          const clientX = e.clientX || e.touches[0].clientX;
          const clientY = e.clientY || e.touches[0].clientY;

          let offsetX = canvas.width / 2;
          let offsetY = canvas.height / 2;

          newPart.style.left = (clientX - rect.left - offsetX) + "px";
          newPart.style.top = (clientY - rect.top - offsetY) + "px";

          function movePart(e) {
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            newPart.style.left = (clientX - rect.left - offsetX) + "px";
            newPart.style.top = (clientY - rect.top - offsetY) + "px";
          }

          function stopDrag() {
            newPart.classList.remove("dragging");
            document.removeEventListener("mousemove", movePart);
            document.removeEventListener("mouseup", stopDrag);
            document.removeEventListener("touchmove", movePart);
            document.removeEventListener("touchend", stopDrag);
            setupPlacedPartDrag(newPart);
          }

          document.addEventListener("mousemove", movePart);
          document.addEventListener("mouseup", stopDrag);
          document.addEventListener("touchmove", movePart, { passive: false });
          document.addEventListener("touchend", stopDrag);
        }
      }

      // é…ç½®æ¸ˆã¿ãƒ‘ãƒ¼ãƒ„ã®ãƒ‰ãƒ©ãƒƒã‚°
      function setupPlacedPartDrag(part) {
        part.addEventListener("mousedown", startPlacedDrag);
        part.addEventListener("touchstart", startPlacedDrag, { passive: false });

        function startPlacedDrag(e) {
          if (isHandMode) return;
          e.preventDefault();
          e.stopPropagation();
          part.classList.add("dragging");

          const rect = faceCanvas.getBoundingClientRect();
          const partRect = part.getBoundingClientRect();
          const clientX = e.clientX || e.touches[0].clientX;
          const clientY = e.clientY || e.touches[0].clientY;

          let offsetX = clientX - partRect.left;
          let offsetY = clientY - partRect.top;

          function movePart(e) {
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            part.style.left = (clientX - rect.left - offsetX) + "px";
            part.style.top = (clientY - rect.top - offsetY) + "px";
          }

          function stopDrag() {
            part.classList.remove("dragging");
            document.removeEventListener("mousemove", movePart);
            document.removeEventListener("mouseup", stopDrag);
            document.removeEventListener("touchmove", movePart);
            document.removeEventListener("touchend", stopDrag);
          }

          document.addEventListener("mousemove", movePart);
          document.addEventListener("mouseup", stopDrag);
          document.addEventListener("touchmove", movePart, { passive: false });
          document.addEventListener("touchend", stopDrag);
        }
      }

      // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒœã‚¿ãƒ³
      document.getElementById("shuffle-btn").addEventListener("click", () => {
        if (!currentLandmarks) {
          alert("å…ˆã«ãƒ‘ãƒ¼ãƒ„ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦ãã ã•ã„");
          return;
        }

        placedParts.forEach(p => p.remove());
        placedParts = [];

        Object.entries(trayCanvases).forEach(([partName, canvas]) => {
          const img = document.createElement("img");
          img.src = canvas.toDataURL();
          img.className = "placed-part";
          img.dataset.part = partName;
          img.style.width = canvas.width + "px";
          img.style.height = canvas.height + "px";
          img.style.left = Math.random() * (faceCanvas.offsetWidth - canvas.width) + "px";
          img.style.top = Math.random() * (faceCanvas.offsetHeight - canvas.height) + "px";

          faceCanvas.appendChild(img);
          placedParts.push(img);
          setupPlacedPartDrag(img);
        });
      });

      // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
      document.getElementById("reset-btn").addEventListener("click", () => {
        placedParts.forEach(p => p.remove());
        placedParts = [];

        if (isGameRunning) {
          clearInterval(gameTimer);
          isGameRunning = false;
          startGameBtn.disabled = false;
          timerDisplay.textContent = "--:--";
          timerDisplay.classList.remove("warning");
        }
      });

      // ä¿å­˜ãƒœã‚¿ãƒ³
      document.getElementById("save-btn").addEventListener("click", () => {
        const saveCanvas = document.createElement("canvas");
        saveCanvas.width = faceCanvas.offsetWidth;
        saveCanvas.height = faceCanvas.offsetHeight;
        const ctx = saveCanvas.getContext("2d");

        ctx.fillStyle = "#fff5f5";
        ctx.beginPath();
        ctx.ellipse(
          saveCanvas.width / 2,
          saveCanvas.height / 2,
          saveCanvas.width / 2 - 5,
          saveCanvas.height / 2 - 5,
          0, 0, Math.PI * 2
        );
        ctx.fill();

        placedParts.forEach(part => {
          const x = parseInt(part.style.left);
          const y = parseInt(part.style.top);
          ctx.drawImage(part, x, y);
        });

        const link = document.createElement("a");
        link.download = "fukuwarai.png";
        link.href = saveCanvas.toDataURL();
        link.click();
      });

      // ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•
      async function startCamera() {
        await initializeMediaPipe();

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“";
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
          });
          videoElement.srcObject = stream;

          videoElement.addEventListener("loadeddata", () => {
            loading.classList.add("hidden");
            console.log("ã‚«ãƒ¡ãƒ©èµ·å‹•å®Œäº†");

            function onFrame() {
              if (!faceLandmarker || !handLandmarker) return;

              const startTimeMs = performance.now();

              if (videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const faceResults = faceLandmarker.detectForVideo(videoElement, startTimeMs);
                const handResults = handLandmarker.detectForVideo(videoElement, startTimeMs);
                processResults(faceResults, handResults);
              }

              requestAnimationFrame(onFrame);
            }
            onFrame();
          });
        } catch (error) {
          console.error("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼:", error);
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—: " + error.message;
        }
      }

      setupDragAndDrop();
      startCamera();
    </script>
  </body>
</html>
