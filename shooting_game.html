<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å°„çš„ã‚²ãƒ¼ãƒ  - çš„ã‚’ã­ã‚‰ãˆï¼</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: #1a1a2e;
        min-height: 100vh;
        overflow: hidden;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #game-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      #video-container {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 240px;
        height: 180px;
        border: 3px solid #ffd700;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        background: #000;
        z-index: 1000;
      }

      #input_video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      /* ç…§æº– */
      #crosshair {
        position: fixed;
        width: 80px;
        height: 80px;
        pointer-events: none;
        z-index: 9999;
        transform: translate(-50%, -50%);
      }

      #crosshair::before,
      #crosshair::after {
        content: "";
        position: absolute;
        background: #ff0000;
      }

      #crosshair::before {
        width: 2px;
        height: 100%;
        left: 50%;
        transform: translateX(-50%);
      }

      #crosshair::after {
        width: 100%;
        height: 2px;
        top: 50%;
        transform: translateY(-50%);
      }

      #crosshair .circle {
        position: absolute;
        width: 40px;
        height: 40px;
        border: 2px solid #ff0000;
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      #crosshair.shooting {
        animation: recoil 0.1s ease-out;
      }

      @keyframes recoil {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.3);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
      }

      #info {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #ffd700;
        max-width: 280px;
        z-index: 1000;
        color: white;
      }

      #info h1 {
        font-size: 20px;
        color: #ffd700;
        margin-bottom: 10px;
      }

      #info p {
        font-size: 14px;
        color: #ddd;
        margin: 5px 0;
      }

      #score {
        font-size: 28px;
        font-weight: bold;
        color: #ffd700;
        margin-top: 10px;
      }

      #ammo {
        font-size: 18px;
        color: #ff6b6b;
        margin-top: 5px;
      }

      #gesture-status {
        margin-top: 10px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        font-size: 14px;
      }

      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 12px;
        border: 2px solid #ffd700;
        text-align: center;
        z-index: 10000;
        color: white;
      }

      #loading.hidden {
        display: none;
      }

      .spinner {
        border: 4px solid #333;
        border-top: 4px solid #ffd700;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* ãƒã‚ºãƒ«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ */
      #muzzle-flash {
        position: fixed;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, rgba(255, 200, 0, 0.8) 0%, rgba(255, 100, 0, 0.4) 50%, transparent 70%);
        pointer-events: none;
        z-index: 9998;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: opacity 0.05s;
      }

      #muzzle-flash.flash {
        opacity: 1;
      }

      /* ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
      .hit-effect {
        position: fixed;
        font-size: 30px;
        font-weight: bold;
        color: #ffd700;
        pointer-events: none;
        z-index: 9000;
        animation: hitPop 0.5s ease-out forwards;
      }

      @keyframes hitPop {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 1;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.5);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -80%) scale(1);
          opacity: 0;
        }
      }

      /* ãƒ”ã‚¹ãƒˆãƒ«ã‚¢ã‚¤ã‚³ãƒ³ */
      #pistol-indicator {
        position: fixed;
        bottom: 20px;
        right: 20px;
        font-size: 60px;
        z-index: 1000;
        filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
        transition: transform 0.1s;
      }

      #pistol-indicator.ready {
        color: #ffd700;
      }

      #pistol-indicator.shooting {
        transform: rotate(-20deg);
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <div class="spinner"></div>
      <p>ã‚«ãƒ¡ãƒ©ã¨MediaPipeã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
    </div>

    <div id="container">
      <canvas id="game-canvas"></canvas>

      <div id="info">
        <h1>çš„ã‚’ã­ã‚‰ãˆï¼</h1>
        <p>ğŸ”« æ‰‹ã‚’ãƒ”ã‚¹ãƒˆãƒ«å‹ã«ã™ã‚‹</p>
        <p>â¬†ï¸ æ‰‹é¦–ã‚’è·³ã­ä¸Šã’ã¦ç™ºå°„ï¼</p>
        <div id="score">ã‚¹ã‚³ã‚¢: 0</div>
        <div id="ammo">å¼¾æ•°: âˆ</div>
        <div id="gesture-status">å¾…æ©Ÿä¸­...</div>
      </div>

      <div id="video-container">
        <video id="input_video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
      </div>

      <div id="crosshair">
        <div class="circle"></div>
      </div>

      <div id="muzzle-flash"></div>
      <div id="pistol-indicator">ğŸ”«</div>
    </div>

    <script type="module">
      import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

      const videoElement = document.getElementById("input_video");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const crosshair = document.getElementById("crosshair");
      const loading = document.getElementById("loading");
      const gameCanvas = document.getElementById("game-canvas");
      const gameCtx = gameCanvas.getContext("2d");
      const scoreElement = document.getElementById("score");
      const gestureStatus = document.getElementById("gesture-status");
      const muzzleFlash = document.getElementById("muzzle-flash");
      const pistolIndicator = document.getElementById("pistol-indicator");

      let handLandmarker = null;
      let lastVideoTime = -1;
      let smoothX = window.innerWidth / 2;
      let smoothY = window.innerHeight / 2;

      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
      let score = 0;
      let targets = [];
      let lastShootTime = 0;

      // ç™ºå°„æ¤œå‡ºç”¨ï¼ˆæ‰‹é¦–ã®ä¸Šä¸‹å‹•ãï¼‰
      let prevWristY = 0;
      let isRecoiling = false;

      // çš„ã®ç¨®é¡
      const targetTypes = [
        { emoji: "ğŸ¯", points: 100, size: 60 },
        { emoji: "ğŸ§¸", points: 150, size: 70 },
        { emoji: "ğŸ¤–", points: 200, size: 80 },
        { emoji: "ğŸ®", points: 250, size: 50 },
        { emoji: "ğŸš—", points: 180, size: 60 },
        { emoji: "ğŸ­", points: 120, size: 40 },
      ];

      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
      function resizeCanvas() {
        gameCanvas.width = window.innerWidth;
        gameCanvas.height = window.innerHeight;
        initTargets();
      }

      // çš„ã‚’åˆæœŸåŒ–
      function initTargets() {
        targets = [];
        const rows = 3;
        const cols = 5;
        const marginX = 150;
        const marginY = 150;
        const spacingX = (gameCanvas.width - marginX * 2) / (cols - 1);
        const spacingY = (gameCanvas.height - marginY * 2) / (rows - 1);

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const type = targetTypes[Math.floor(Math.random() * targetTypes.length)];
            targets.push({
              x: marginX + col * spacingX + (Math.random() - 0.5) * 40,
              y: marginY + row * spacingY + (Math.random() - 0.5) * 30,
              size: type.size,
              emoji: type.emoji,
              points: type.points,
              isHit: false,
              hitTime: 0,
            });
          }
        }
      }

      // èƒŒæ™¯ã‚’æç”»ï¼ˆãŠç¥­ã‚Šã®å°„çš„å±‹å°é¢¨ï¼‰
      function drawBackground() {
        // èƒŒæ™¯è‰²
        const gradient = gameCtx.createLinearGradient(0, 0, 0, gameCanvas.height);
        gradient.addColorStop(0, "#2c1810");
        gradient.addColorStop(1, "#1a0f0a");
        gameCtx.fillStyle = gradient;
        gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

        // èµ¤ç™½ã®ç¸¦ç¸ï¼ˆå±‹å°ã®è£…é£¾ï¼‰
        const stripeWidth = 80;
        for (let i = 0; i < gameCanvas.width / stripeWidth; i++) {
          if (i % 2 === 0) {
            gameCtx.fillStyle = "#cc0000";
          } else {
            gameCtx.fillStyle = "#ffffff";
          }
          gameCtx.fillRect(i * stripeWidth, 0, stripeWidth, 60);
          gameCtx.fillRect(i * stripeWidth, gameCanvas.height - 60, stripeWidth, 60);
        }

        // æç¯ã‚’æç”»
        const lanternSpacing = 150;
        for (let x = 75; x < gameCanvas.width; x += lanternSpacing) {
          drawLantern(x, 90);
        }

        // æ£šã‚’æç”»
        gameCtx.fillStyle = "#8B4513";
        const shelfY = [200, 350, 500];
        shelfY.forEach((y) => {
          if (y < gameCanvas.height - 100) {
            gameCtx.fillRect(50, y, gameCanvas.width - 100, 15);
          }
        });
      }

      // æç¯ã‚’æç”»
      function drawLantern(x, y) {
        gameCtx.fillStyle = "#ff3333";
        gameCtx.beginPath();
        gameCtx.ellipse(x, y, 25, 35, 0, 0, Math.PI * 2);
        gameCtx.fill();

        // æç¯ã®ç¸æ¨¡æ§˜
        gameCtx.strokeStyle = "#cc0000";
        gameCtx.lineWidth = 2;
        for (let i = -20; i <= 20; i += 10) {
          gameCtx.beginPath();
          gameCtx.moveTo(x - 20, y + i);
          gameCtx.lineTo(x + 20, y + i);
          gameCtx.stroke();
        }

        // ç´
        gameCtx.strokeStyle = "#333";
        gameCtx.lineWidth = 2;
        gameCtx.beginPath();
        gameCtx.moveTo(x, y - 35);
        gameCtx.lineTo(x, y - 55);
        gameCtx.stroke();
      }

      // çš„ã‚’æç”»
      function drawTargets() {
        targets.forEach((target) => {
          if (target.isHit) {
            // ãƒ’ãƒƒãƒˆå¾Œã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
            const elapsed = Date.now() - target.hitTime;
            if (elapsed < 500) {
              gameCtx.globalAlpha = 1 - elapsed / 500;
              gameCtx.font = `${target.size}px Arial`;
              gameCtx.textAlign = "center";
              gameCtx.textBaseline = "middle";
              gameCtx.fillText(target.emoji, target.x, target.y);
              gameCtx.globalAlpha = 1;
            }
          } else {
            gameCtx.font = `${target.size}px Arial`;
            gameCtx.textAlign = "center";
            gameCtx.textBaseline = "middle";
            gameCtx.fillText(target.emoji, target.x, target.y);
          }
        });
      }

      // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      function render() {
        gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        drawBackground();
        drawTargets();
        requestAnimationFrame(render);
      }

      // ç™ºå°„å‡¦ç†
      function shoot(x, y) {
        const now = Date.now();
        if (now - lastShootTime < 300) return; // é€£å°„åˆ¶é™
        lastShootTime = now;

        // ãƒã‚ºãƒ«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
        muzzleFlash.style.left = `${x}px`;
        muzzleFlash.style.top = `${y}px`;
        muzzleFlash.classList.add("flash");
        crosshair.classList.add("shooting");
        pistolIndicator.classList.add("shooting");

        setTimeout(() => {
          muzzleFlash.classList.remove("flash");
          crosshair.classList.remove("shooting");
          pistolIndicator.classList.remove("shooting");
        }, 100);

        // å½“ãŸã‚Šåˆ¤å®š
        let hit = false;
        targets.forEach((target) => {
          if (target.isHit) return;
          const dx = x - target.x;
          const dy = y - target.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < target.size * 0.6) {
            target.isHit = true;
            target.hitTime = now;
            score += target.points;
            scoreElement.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
            hit = true;

            // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            const effect = document.createElement("div");
            effect.className = "hit-effect";
            effect.textContent = `+${target.points}`;
            effect.style.left = `${target.x}px`;
            effect.style.top = `${target.y}px`;
            document.body.appendChild(effect);
            setTimeout(() => effect.remove(), 500);
          }
        });

        // å…¨éƒ¨å€’ã—ãŸã‚‰å†ç”Ÿæˆ
        if (targets.every((t) => t.isHit)) {
          setTimeout(initTargets, 1000);
        }
      }

      // ãƒ”ã‚¹ãƒˆãƒ«ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ¤œå‡º
      function detectPistolGesture(landmarks) {
        // æ‰‹é¦–
        const wrist = landmarks[0];

        // äººå·®ã—æŒ‡ã®å…ˆç«¯ã¨æ ¹å…ƒ
        const indexTip = landmarks[8];
        const indexMcp = landmarks[5];

        // è¦ªæŒ‡
        const thumbTip = landmarks[4];

        // ä¸­æŒ‡ã€è–¬æŒ‡ã€å°æŒ‡ï¼ˆæ›²ãŒã£ã¦ã„ã‚‹ã‹ï¼‰
        const middleTip = landmarks[12];
        const middleMcp = landmarks[9];
        const ringTip = landmarks[16];
        const ringMcp = landmarks[13];
        const pinkyTip = landmarks[20];
        const pinkyMcp = landmarks[17];

        // äººå·®ã—æŒ‡ãŒä¼¸ã³ã¦ã„ã‚‹ã‹
        const indexExtended = indexTip.y < indexMcp.y - 0.03;

        // ä¸­æŒ‡ã€è–¬æŒ‡ã€å°æŒ‡ãŒæ›²ãŒã£ã¦ã„ã‚‹ã‹
        const middleBent = middleTip.y > middleMcp.y - 0.02;
        const ringBent = ringTip.y > ringMcp.y - 0.02;
        const pinkyBent = pinkyTip.y > pinkyMcp.y - 0.02;

        // ãƒ”ã‚¹ãƒˆãƒ«å‹ã®åˆ¤å®š
        const isPistolShape = indexExtended && middleBent && ringBent && pinkyBent;

        // ç™ºå°„æ¤œå‡ºï¼šæ‰‹é¦–ã‚’ä¸Šã«è·³ã­ä¸Šã’ã‚‹ï¼ˆYåº§æ¨™ãŒæ€¥ã«å°ã•ããªã‚‹ï¼ä¸Šã«å‹•ãï¼‰
        const currentWristY = wrist.y;
        const yVelocity = prevWristY - currentWristY; // æ­£ã®å€¤ = ä¸Šã«å‹•ã„ã¦ã„ã‚‹

        // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½ç½®ã‚’ä¿å­˜
        prevWristY = currentWristY;

        // æ’ƒã¤å‹•ä½œï¼šæ‰‹é¦–ã‚’ç´ æ—©ãä¸Šã«è·³ã­ä¸Šã’ã‚‹
        const shootThreshold = 0.02; // ã“ã®å€¤ã‚’èª¿æ•´ã—ã¦æ„Ÿåº¦ã‚’å¤‰ãˆã‚‹
        const isShooting = yVelocity > shootThreshold && isPistolShape;

        return {
          isPistol: isPistolShape,
          isTrigger: isShooting,
          yVelocity: yVelocity,
        };
      }

      // MediaPipeåˆæœŸåŒ–
      async function initializeHandLandmarker() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.7,
          minHandPresenceConfidence: 0.7,
          minTrackingConfidence: 0.7,
        });
      }

      function processHandLandmarks(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.landmarks && results.landmarks.length > 0) {
          const landmarks = results.landmarks[0];

          // æ‰‹ã®éª¨æ ¼ã‚’æç”»
          canvasCtx.strokeStyle = "#ffd700";
          canvasCtx.lineWidth = 2;

          const connections = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 4],
            [0, 5],
            [5, 6],
            [6, 7],
            [7, 8],
            [0, 9],
            [9, 10],
            [10, 11],
            [11, 12],
            [0, 13],
            [13, 14],
            [14, 15],
            [15, 16],
            [0, 17],
            [17, 18],
            [18, 19],
            [19, 20],
            [5, 9],
            [9, 13],
            [13, 17],
          ];

          connections.forEach(([start, end]) => {
            const startPoint = landmarks[start];
            const endPoint = landmarks[end];
            canvasCtx.beginPath();
            canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
            canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
            canvasCtx.stroke();
          });

          // äººå·®ã—æŒ‡ã®å…ˆç«¯ã§ç…§æº–ã‚’å‹•ã‹ã™
          const indexFingerTip = landmarks[8];
          const targetX = (1.0 - indexFingerTip.x) * window.innerWidth;
          const targetY = indexFingerTip.y * window.innerHeight;

          smoothX += (targetX - smoothX) * 0.3;
          smoothY += (targetY - smoothY) * 0.3;

          crosshair.style.left = `${smoothX}px`;
          crosshair.style.top = `${smoothY}px`;
          crosshair.style.display = "block";

          // ãƒ”ã‚¹ãƒˆãƒ«ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ¤œå‡º
          const gesture = detectPistolGesture(landmarks);

          if (gesture.isPistol) {
            pistolIndicator.classList.add("ready");
            gestureStatus.textContent = `ğŸ”« æ§‹ãˆä¸­... (è·³ã­ä¸Šã’ã¦ç™ºå°„ï¼)`;
            gestureStatus.style.color = "#ffd700";

            // æ’ƒã¤å‹•ä½œã‚’æ¤œå‡ºã—ãŸã‚‰ç™ºå°„
            if (gesture.isTrigger) {
              shoot(smoothX, smoothY);
              gestureStatus.textContent = "ğŸ’¥ ç™ºå°„ï¼";
            }
          } else {
            pistolIndicator.classList.remove("ready");
            gestureStatus.textContent = "æ‰‹ã‚’ãƒ”ã‚¹ãƒˆãƒ«å‹ã«...";
            gestureStatus.style.color = "#888";
          }
        } else {
          gestureStatus.textContent = "æ‰‹ãŒè¦‹ãˆã¾ã›ã‚“...";
          gestureStatus.style.color = "#ff6b6b";
          pistolIndicator.classList.remove("ready");
        }

        canvasCtx.restore();
      }

      async function startCamera() {
        await initializeHandLandmarker();

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“";
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
          });
          videoElement.srcObject = stream;

          videoElement.addEventListener("loadeddata", () => {
            loading.classList.add("hidden");

            function onFrame() {
              if (!handLandmarker) return;

              const startTimeMs = performance.now();

              if (videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                processHandLandmarks(results);
              }

              requestAnimationFrame(onFrame);
            }
            onFrame();
          });
        } catch (error) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—: " + error.message;
        }
      }

      // åˆæœŸåŒ–
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      render();
      startCamera();
    </script>
  </body>
</html>
