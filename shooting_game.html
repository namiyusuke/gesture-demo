<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å°„çš„ã‚²ãƒ¼ãƒ  - çš„ã‚’ã­ã‚‰ãˆï¼</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: #fff;
        min-height: 100vh;
        overflow: hidden;
      }

      #container {
        position: relative;
        width: 100vw;
        height: 100vh;
        margin-top: 100px;
        background-image: url("shooting_game-images/shooting-bg.png");
        background-size: calc(1200 / 1440 * 100vw);
        background-position: center;
        background-repeat: no-repeat;
      }

      #game-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      #video-container {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 240px;
        height: 180px;
        border: 3px solid #ffd700;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        background: #000;
        z-index: 1000;
      }

      #input_video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #output_canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      /* ç…§æº–ï¼ˆæŒ‡ã‚«ãƒ¼ã‚½ãƒ«ï¼‰ */
      #crosshair {
        position: fixed;
        width: 100px;
        height: 100px;
        pointer-events: none;
        z-index: 9999;
        transform: translate(-50%, -50%);
        background-image: url("shooting_game-images/target-mouse.png");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }

      #crosshair.shooting {
        animation: recoil 0.1s ease-out;
      }

      @keyframes recoil {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.3);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
      }

      #info {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #ffd700;
        max-width: 280px;
        z-index: 1000;
        color: white;
      }

      #info h1 {
        font-size: 20px;
        color: #ffd700;
        margin-bottom: 10px;
      }

      #info p {
        font-size: 14px;
        color: #ddd;
        margin: 5px 0;
      }

      #score {
        font-size: 28px;
        font-weight: bold;
        color: #ffd700;
        margin-top: 10px;
      }

      #ammo {
        font-size: 18px;
        color: #ff6b6b;
        margin-top: 5px;
      }

      #gesture-status {
        margin-top: 10px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        font-size: 14px;
      }

      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 12px;
        border: 2px solid #ffd700;
        text-align: center;
        z-index: 10000;
        color: white;
      }

      #loading.hidden {
        display: none;
      }

      .spinner {
        border: 4px solid #333;
        border-top: 4px solid #ffd700;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* ãƒã‚ºãƒ«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ */
      #muzzle-flash {
        position: fixed;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, rgba(255, 200, 0, 0.8) 0%, rgba(255, 100, 0, 0.4) 50%, transparent 70%);
        pointer-events: none;
        z-index: 9998;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: opacity 0.05s;
      }

      #muzzle-flash.flash {
        opacity: 1;
      }

      /* ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
      .hit-effect {
        position: fixed;
        font-size: 30px;
        font-weight: bold;
        color: #ffd700;
        pointer-events: none;
        z-index: 9000;
        animation: hitPop 0.5s ease-out forwards;
      }

      @keyframes hitPop {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 1;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.5);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -80%) scale(1);
          opacity: 0;
        }
      }

      /* ãƒ”ã‚¹ãƒˆãƒ«ã‚¢ã‚¤ã‚³ãƒ³ */
      #pistol-indicator {
        position: fixed;
        bottom: 20px;
        right: 20px;
        font-size: 60px;
        z-index: 1000;
        filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
        transition: transform 0.1s;
      }

      #pistol-indicator.ready {
        color: #ffd700;
      }

      #pistol-indicator.shooting {
        transform: rotate(-20deg);
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <div class="spinner"></div>
      <p>ã‚«ãƒ¡ãƒ©ã¨MediaPipeã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
    </div>

    <div id="container">
      <canvas id="game-canvas"></canvas>

      <div id="info">
        <h1>çš„ã‚’ã­ã‚‰ãˆï¼</h1>
        <p>â˜ï¸ äººå·®ã—æŒ‡ã‚’ä¼¸ã°ã—ã¦ç‹™ã†</p>
        <p>ğŸ‘† æŒ‡ã‚’æ›²ã’ã¦ç™ºå°„ï¼</p>
        <div id="score">ã‚¹ã‚³ã‚¢: 0</div>
        <div id="ammo">å¼¾æ•°: âˆ</div>
        <div id="gesture-status">å¾…æ©Ÿä¸­...</div>
      </div>

      <div id="video-container">
        <video id="input_video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
      </div>

      <div id="crosshair"></div>

      <div id="muzzle-flash"></div>
      <div id="pistol-indicator">â˜ï¸</div>
    </div>

    <script type="module">
      import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

      const videoElement = document.getElementById("input_video");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const crosshair = document.getElementById("crosshair");
      const loading = document.getElementById("loading");
      const gameCanvas = document.getElementById("game-canvas");
      const gameCtx = gameCanvas.getContext("2d");
      const scoreElement = document.getElementById("score");
      const gestureStatus = document.getElementById("gesture-status");
      const muzzleFlash = document.getElementById("muzzle-flash");
      const pistolIndicator = document.getElementById("pistol-indicator");

      let handLandmarker = null;
      let lastVideoTime = -1;
      let smoothX = window.innerWidth / 2;
      let smoothY = window.innerHeight / 2;

      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
      let score = 0;
      let targets = [];
      let lastShootTime = 0;

      // ç™ºå°„æ¤œå‡ºç”¨ï¼ˆäººå·®ã—æŒ‡ã‚’æ›²ã’ã¦ç™ºå°„ï¼‰
      let indexExtendedHistory = []; // äººå·®ã—æŒ‡ã®çŠ¶æ…‹å±¥æ­´
      const HISTORY_LENGTH = 5; // å±¥æ­´ã®é•·ã•
      let canShoot = true; // ç™ºå°„å¯èƒ½ãƒ•ãƒ©ã‚°ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ç”¨ï¼‰

      // çš„ã®ç¨®é¡ï¼ˆç”»åƒã‚’ä½¿ç”¨ï¼‰
      const targetTypes = [
        { image: "shooting_game-images/target01.png", points: 100, size: 80 },
        { image: "shooting_game-images/target02.png", points: 120, size: 80 },
        { image: "shooting_game-images/target03.png", points: 150, size: 80 },
        { image: "shooting_game-images/target04.png", points: 180, size: 80 },
        { image: "shooting_game-images/target05.png", points: 200, size: 80 },
        { image: "shooting_game-images/target06.png", points: 220, size: 80 },
        { image: "shooting_game-images/target07.png", points: 250, size: 80 },
        { image: "shooting_game-images/target08.png", points: 280, size: 80 },
        { image: "shooting_game-images/target09.png", points: 300, size: 80 },
        { image: "shooting_game-images/target10.png", points: 350, size: 80 },
        { image: "shooting_game-images/target11.png", points: 400, size: 80 },
        { image: "shooting_game-images/target12.png", points: 500, size: 80 },
      ];

      // çš„ç”»åƒã‚’ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
      const targetImages = {};
      targetTypes.forEach((type) => {
        const img = new Image();
        img.src = type.image;
        targetImages[type.image] = img;
      });

      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
      function resizeCanvas() {
        gameCanvas.width = window.innerWidth;
        gameCanvas.height = window.innerHeight;
        initTargets();
      }

      // çš„ã‚’åˆæœŸåŒ–ï¼ˆæ£šã®ä½ç½®ã«é…ç½®ï¼‰
      function initTargets() {
        targets = [];

        const shelfRows = [
          { y: 0.28, count: 5, size: 140 },
          { y: 0.48, count: 6, size: 160 },
          { y: 0.68, count: 4, size: 180 },
        ];

        const marginX = gameCanvas.width * 0.15;
        const usableWidth = gameCanvas.width * 0.7;

        shelfRows.forEach((shelf) => {
          const spacingX = usableWidth / (shelf.count - 1);
          for (let i = 0; i < shelf.count; i++) {
            const type = targetTypes[Math.floor(Math.random() * targetTypes.length)];
            targets.push({
              x: marginX + i * spacingX + (Math.random() - 0.5) * 20,
              y: gameCanvas.height * shelf.y - shelf.size * 0.5,
              size: shelf.size,
              image: type.image,
              points: type.points,
              isHit: false,
              hitTime: 0,
              vx: 0,
              vy: 0,
              rotation: 0,
              rotationSpeed: 0,
            });
          }
        });
      }

      // èƒŒæ™¯ã¯ç”»åƒã§è¡¨ç¤ºï¼ˆCSSã§è¨­å®šæ¸ˆã¿ï¼‰

      // çš„ã‚’æç”»ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒï¼‰+ é£›ã‚“ã§ã„ãã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      function drawTargets() {
        const gravity = 0.5; // é‡åŠ›

        targets.forEach((target) => {
          const img = targetImages[target.image];
          if (!img || !img.complete) return;

          // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
          const aspectRatio = img.naturalWidth / img.naturalHeight;
          let drawWidth, drawHeight;
          if (aspectRatio > 1) {
            drawWidth = target.size;
            drawHeight = target.size / aspectRatio;
          } else {
            drawHeight = target.size;
            drawWidth = target.size * aspectRatio;
          }

          if (target.isHit) {
            const elapsed = Date.now() - target.hitTime;

            // ç‰©ç†æ¼”ç®—ï¼šé€Ÿåº¦ã‚’æ›´æ–°
            target.vy += gravity;
            target.x += target.vx;
            target.y += target.vy;
            target.rotation += target.rotationSpeed;

            // ç”»é¢å¤–ã«å‡ºãŸã‚‰æç”»ã—ãªã„
            if (target.y > gameCanvas.height + 200) return;

            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã—ãªãŒã‚‰é£›ã‚“ã§ã„ã
            const alpha = Math.max(0, 1 - elapsed / 1500);
            if (alpha <= 0) return;

            gameCtx.save();
            gameCtx.globalAlpha = alpha;
            gameCtx.translate(target.x, target.y);
            gameCtx.rotate(target.rotation);
            gameCtx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
            gameCtx.restore();
          } else {
            gameCtx.drawImage(img, target.x - drawWidth / 2, target.y - drawHeight / 2, drawWidth, drawHeight);
          }
        });
      }

      // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      function render() {
        gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        drawTargets();
        updateParticles();
        drawParticles();
        requestAnimationFrame(render);
      }

      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      let particles = [];

      function createParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
          const speed = 3 + Math.random() * 5;
          particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            color: color,
            size: 3 + Math.random() * 4,
          });
        }
      }

      function updateParticles() {
        particles = particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.2; // é‡åŠ›
          p.life -= 0.03;
          return p.life > 0;
        });
      }

      function drawParticles() {
        particles.forEach((p) => {
          gameCtx.globalAlpha = p.life;
          gameCtx.fillStyle = p.color;
          gameCtx.beginPath();
          gameCtx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
          gameCtx.fill();
        });
        gameCtx.globalAlpha = 1;
      }

      // ç”»é¢æºã‚Œã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      function shakeScreen(intensity = 10) {
        const container = document.getElementById("container");
        const duration = 150;
        const startTime = Date.now();

        function shake() {
          const elapsed = Date.now() - startTime;
          if (elapsed < duration) {
            const remaining = 1 - elapsed / duration;
            const offsetX = (Math.random() - 0.5) * intensity * remaining;
            const offsetY = (Math.random() - 0.5) * intensity * remaining;
            container.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            requestAnimationFrame(shake);
          } else {
            container.style.transform = "";
          }
        }
        shake();
      }

      // ç™ºå°„å‡¦ç†
      function shoot(x, y) {
        const now = Date.now();
        if (now - lastShootTime < 300) return; // é€£å°„åˆ¶é™
        lastShootTime = now;

        // ãƒã‚ºãƒ«ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆå¼·åŒ–ç‰ˆï¼‰
        muzzleFlash.style.left = `${x}px`;
        muzzleFlash.style.top = `${y}px`;
        muzzleFlash.classList.add("flash");
        crosshair.classList.add("shooting");
        pistolIndicator.classList.add("shooting");

        // ç™ºå°„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        createParticles(x, y, "#ffaa00", 8);

        setTimeout(() => {
          muzzleFlash.classList.remove("flash");
          crosshair.classList.remove("shooting");
          pistolIndicator.classList.remove("shooting");
        }, 100);

        // å½“ãŸã‚Šåˆ¤å®š
        let hit = false;
        targets.forEach((target) => {
          if (target.isHit) return;
          const dx = x - target.x;
          const dy = y - target.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < target.size * 0.6) {
            target.isHit = true;
            target.hitTime = now;
            score += target.points;
            scoreElement.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
            hit = true;

            // çš„ãŒé£›ã‚“ã§ã„ãé€Ÿåº¦ã‚’è¨­å®šï¼ˆæ’ƒã£ãŸæ–¹å‘ã‹ã‚‰è·³ã­è¿”ã‚‹ï¼‰
            const hitAngle = Math.atan2(dy, dx);
            const knockbackSpeed = 8 + Math.random() * 4;
            target.vx = -Math.cos(hitAngle) * knockbackSpeed + (Math.random() - 0.5) * 4;
            target.vy = -Math.abs(Math.sin(hitAngle)) * knockbackSpeed - 5 - Math.random() * 3;
            target.rotationSpeed = (Math.random() - 0.5) * 0.3;

            // ãƒ’ãƒƒãƒˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆæ´¾æ‰‹ã«ï¼‰
            createParticles(target.x, target.y, "#ff4444", 12);
            createParticles(target.x, target.y, "#ffff00", 8);

            // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆå¾—ç‚¹è¡¨ç¤ºï¼‰
            const effect = document.createElement("div");
            effect.className = "hit-effect";
            effect.textContent = `+${target.points}`;
            effect.style.left = `${target.x}px`;
            effect.style.top = `${target.y}px`;
            document.body.appendChild(effect);
            setTimeout(() => effect.remove(), 800);
          }
        });

        // å…¨éƒ¨å€’ã—ãŸã‚‰å†ç”Ÿæˆ
        if (targets.every((t) => t.isHit)) {
          setTimeout(initTargets, 1500);
        }
      }

      // ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ¤œå‡ºï¼ˆäººå·®ã—æŒ‡ã‚’æ›²ã’ã¦ç™ºå°„ï¼‰- å®‰å®šåŒ–ç‰ˆ
      function detectGesture(landmarks) {
        // äººå·®ã—æŒ‡ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯
        const indexTip = landmarks[8]; // å…ˆç«¯
        const indexDip = landmarks[7]; // ç¬¬ä¸€é–¢ç¯€
        const indexPip = landmarks[6]; // ç¬¬äºŒé–¢ç¯€
        const indexMcp = landmarks[5]; // ä»˜ã‘æ ¹

        // æŒ‡ã®æ›²ã’å…·åˆã‚’æ•°å€¤åŒ–ï¼ˆ0=å®Œå…¨ã«ä¼¸ã³ã¦ã„ã‚‹ã€1=å®Œå…¨ã«æ›²ãŒã£ã¦ã„ã‚‹ï¼‰
        const bendAmount = (indexTip.y - indexPip.y) / 0.1; // æ­£è¦åŒ–
        const clampedBend = Math.max(0, Math.min(1, bendAmount + 0.5));

        // å±¥æ­´ã«è¿½åŠ 
        indexExtendedHistory.push(clampedBend);
        if (indexExtendedHistory.length > HISTORY_LENGTH) {
          indexExtendedHistory.shift();
        }

        // å±¥æ­´ã®å¹³å‡ã‚’è¨ˆç®—ï¼ˆã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ï¼‰
        const avgBend = indexExtendedHistory.reduce((a, b) => a + b, 0) / indexExtendedHistory.length;

        // é–¾å€¤ã§åˆ¤å®š
        const isExtended = avgBend < 0.3; // ä¼¸ã³ã¦ã„ã‚‹
        const isBent = avgBend > 0.6; // æ›²ãŒã£ã¦ã„ã‚‹

        // æ§‹ãˆçŠ¶æ…‹ï¼šäººå·®ã—æŒ‡ãŒä¼¸ã³ã¦ã„ã‚‹
        const isReady = isExtended;

        // ç™ºå°„åˆ¤å®šï¼šä¼¸ã³ã¦ã„ã‚‹çŠ¶æ…‹ã‹ã‚‰æ›²ãŒã£ãŸçŠ¶æ…‹ã¸ã®é·ç§»ã‚’æ¤œå‡º
        let isTrigger = false;
        if (canShoot && indexExtendedHistory.length >= HISTORY_LENGTH) {
          // å±¥æ­´ã®å‰åŠã¨å¾ŒåŠã‚’æ¯”è¼ƒ
          const firstHalf = indexExtendedHistory.slice(0, Math.floor(HISTORY_LENGTH / 2));
          const secondHalf = indexExtendedHistory.slice(Math.floor(HISTORY_LENGTH / 2));
          const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
          const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;

          // å‰åŠãŒä¼¸ã³ã¦ã„ã¦ã€å¾ŒåŠãŒæ›²ãŒã£ã¦ã„ã‚‹å ´åˆã«ç™ºå°„
          if (firstAvg < 0.35 && secondAvg > 0.55) {
            isTrigger = true;
            canShoot = false;
            // ç™ºå°„å¾Œã€æŒ‡ã‚’ä¼¸ã°ã™ã¾ã§å†ç™ºå°„ä¸å¯
            setTimeout(() => {
              if (avgBend < 0.3) canShoot = true;
            }, 200);
          }
        }

        // æŒ‡ãŒä¼¸ã³ãŸã‚‰å†ç™ºå°„å¯èƒ½ã«
        if (isExtended && !canShoot) {
          canShoot = true;
        }

        return {
          isReady: isReady,
          isTrigger: isTrigger,
          indexBent: isBent,
          bendAmount: avgBend, // ãƒ‡ãƒãƒƒã‚°ç”¨
        };
      }

      // MediaPipeåˆæœŸåŒ–
      async function initializeHandLandmarker() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 1,
          minHandDetectionConfidence: 0.7,
          minHandPresenceConfidence: 0.7,
          minTrackingConfidence: 0.7,
        });
      }

      function processHandLandmarks(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.landmarks && results.landmarks.length > 0) {
          const landmarks = results.landmarks[0];

          // æ‰‹ã®éª¨æ ¼ã‚’æç”»
          canvasCtx.strokeStyle = "#ffd700";
          canvasCtx.lineWidth = 2;

          const connections = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 4],
            [0, 5],
            [5, 6],
            [6, 7],
            [7, 8],
            [0, 9],
            [9, 10],
            [10, 11],
            [11, 12],
            [0, 13],
            [13, 14],
            [14, 15],
            [15, 16],
            [0, 17],
            [17, 18],
            [18, 19],
            [19, 20],
            [5, 9],
            [9, 13],
            [13, 17],
          ];

          connections.forEach(([start, end]) => {
            const startPoint = landmarks[start];
            const endPoint = landmarks[end];
            canvasCtx.beginPath();
            canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
            canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
            canvasCtx.stroke();
          });

          // äººå·®ã—æŒ‡ã®å…ˆç«¯ã§ç…§æº–ã‚’å‹•ã‹ã™
          const indexFingerTip = landmarks[8];
          const targetX = (1.0 - indexFingerTip.x) * window.innerWidth;
          const targetY = indexFingerTip.y * window.innerHeight;

          smoothX += (targetX - smoothX) * 0.3;
          smoothY += (targetY - smoothY) * 0.3;

          crosshair.style.left = `${smoothX}px`;
          crosshair.style.top = `${smoothY}px`;
          crosshair.style.display = "block";

          // ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ¤œå‡ºï¼ˆäººå·®ã—æŒ‡ã‚’æ›²ã’ã¦ç™ºå°„ï¼‰
          const gesture = detectGesture(landmarks);

          // æ›²ã’å…·åˆã®ãƒãƒ¼è¡¨ç¤º
          const bendPercent = Math.round(gesture.bendAmount * 100);
          const bendBar = "â–ˆ".repeat(Math.round(bendPercent / 10)) + "â–‘".repeat(10 - Math.round(bendPercent / 10));

          if (gesture.isReady) {
            pistolIndicator.classList.add("ready");
            gestureStatus.innerHTML = `â˜ï¸ æ§‹ãˆä¸­ï¼<br><small>${bendBar} ${bendPercent}%</small>`;
            gestureStatus.style.color = "#ffd700";
          } else if (gesture.indexBent) {
            gestureStatus.innerHTML = `ğŸ‘† æ›²ã’ãŸï¼<br><small>${bendBar} ${bendPercent}%</small>`;
            gestureStatus.style.color = "#ff6b6b";
          } else {
            pistolIndicator.classList.remove("ready");
            gestureStatus.innerHTML = `â˜ï¸ æŒ‡ã‚’ä¼¸ã°ã—ã¦...<br><small>${bendBar} ${bendPercent}%</small>`;
            gestureStatus.style.color = "#888";
          }

          // ç™ºå°„åˆ¤å®š
          if (gesture.isTrigger) {
            shoot(smoothX, smoothY);
            gestureStatus.innerHTML = "ğŸ’¥ ç™ºå°„ï¼";
          }
        } else {
          gestureStatus.textContent = "æ‰‹ãŒè¦‹ãˆã¾ã›ã‚“...";
          gestureStatus.style.color = "#ff6b6b";
          pistolIndicator.classList.remove("ready");
        }

        canvasCtx.restore();
      }

      async function startCamera() {
        await initializeHandLandmarker();

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©APIã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“";
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
          });
          videoElement.srcObject = stream;

          videoElement.addEventListener("loadeddata", () => {
            loading.classList.add("hidden");

            function onFrame() {
              if (!handLandmarker) return;

              const startTimeMs = performance.now();

              if (videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                processHandLandmarks(results);
              }

              requestAnimationFrame(onFrame);
            }
            onFrame();
          });
        } catch (error) {
          loading.querySelector("p").textContent = "ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—: " + error.message;
        }
      }

      // åˆæœŸåŒ–
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      render();
      startCamera();
    </script>
  </body>
</html>
